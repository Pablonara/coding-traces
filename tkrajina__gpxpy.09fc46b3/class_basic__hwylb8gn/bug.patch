diff --git a/gpxpy/gpx.py b/gpxpy/gpx.py
index 73e2024..08e1da6 100644
--- a/gpxpy/gpx.py
+++ b/gpxpy/gpx.py
@@ -140,12 +140,194 @@ class PointData(NamedTuple):
     point_no: int
 
 
-class GPXException(Exception):
+class BlackBody(Fittable1DModel):
     """
-    Exception used for invalid GPX files. It is used when the XML file is
-    valid but something is wrong with the GPX data.
+    Blackbody model using the Planck function.
+
+    Parameters
+    ----------
+    temperature : `~astropy.units.Quantity` ['temperature']
+        Blackbody temperature.
+
+    scale : float or `~astropy.units.Quantity` ['dimensionless']
+        Scale factor.  If dimensionless, input units will assumed
+        to be in Hz and output units in (erg / (cm ** 2 * s * Hz * sr).
+        If not dimensionless, must be equivalent to either
+        (erg / (cm ** 2 * s * Hz * sr) or erg / (cm ** 2 * s * AA * sr),
+        in which case the result will be returned in the requested units and
+        the scale will be stripped of units (with the float value applied).
+
+    Notes
+    -----
+
+    Model formula:
+
+        .. math:: B_{\\nu}(T) = A \\frac{2 h \\nu^{3} / c^{2}}{exp(h \\nu / k T) - 1}
+
+    Examples
+    --------
+    >>> from astropy.modeling import models
+    >>> from astropy import units as u
+    >>> bb = models.BlackBody(temperature=5000*u.K)
+    >>> bb(6000 * u.AA)  # doctest: +FLOAT_CMP
+    <Quantity 1.53254685e-05 erg / (cm2 Hz s sr)>
+
+    .. plot::
+        :include-source:
+
+        import numpy as np
+        import matplotlib.pyplot as plt
+
+        from astropy.modeling.models import BlackBody
+        from astropy import units as u
+        from astropy.visualization import quantity_support
+
+        bb = BlackBody(temperature=5778*u.K)
+        wav = np.arange(1000, 110000) * u.AA
+        flux = bb(wav)
+
+        with quantity_support():
+            plt.figure()
+            plt.semilogx(wav, flux)
+            plt.axvline(bb.nu_max.to(u.AA, equivalencies=u.spectral()).value, ls='--')
+            plt.show()
     """
-    pass
+
+    temperature = Parameter(default=5000.0, min=0, unit=u.K, description="Blackbody temperature")
+    scale = Parameter(default=1.0, min=0, description="Scale factor")
+
+    _input_units_allow_dimensionless = True
+    input_units_equivalencies = {'x': u.spectral()}
+
+    _native_units = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)
+    _native_output_units = {'SNU': u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr),
+                            'SLAM': u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)}
+
+    def __init__(self, *args, **kwargs):
+        scale = kwargs.get('scale', None)
+
+        if hasattr(scale, 'unit') and not scale.unit.is_equivalent(u.dimensionless_unscaled):
+            output_units = scale.unit
+            if not output_units.is_equivalent(self._native_units, u.spectral_density(1*u.AA)):
+                raise ValueError(f"scale units not dimensionless or in surface brightness: {output_units}")
+
+            kwargs['scale'] = scale.value
+            self._output_units = output_units
+        else:
+            self._output_units = self._native_units
+
+        return super().__init__(*args, **kwargs)
+
+    def evaluate(self, x, temperature, scale):
+        """Evaluate the model.
+
+        Parameters
+        ----------
+        x : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['frequency']
+            Frequency at which to compute the blackbody. If no units are given,
+            this defaults to Hz (or AA if `scale` was initialized with units
+            equivalent to erg / (cm ** 2 * s * AA * sr)).
+
+        temperature : float, `~numpy.ndarray`, or `~astropy.units.Quantity`
+            Temperature of the blackbody. If no units are given, this defaults
+            to Kelvin.
+
+        scale : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['dimensionless']
+            Desired scale for the blackbody.
+
+        Returns
+        -------
+        y : number or ndarray
+            Blackbody spectrum. The units are determined from the units of
+            ``scale``.
+
+        .. note::
+
+            Use `numpy.errstate` to suppress Numpy warnings, if desired.
+
+        .. warning::
+
+            Output values might contain ``nan`` and ``inf``.
+
+        Raises
+        ------
+        ValueError
+            Invalid temperature.
+
+        ZeroDivisionError
+            Wavelength is zero (when converting to frequency).
+        """
+        if not isinstance(temperature, u.Quantity):
+            in_temp = u.Quantity(temperature, u.K)
+        else:
+            in_temp = temperature
+
+        if not isinstance(x, u.Quantity):
+            in_x = u.Quantity(x, self.input_units['x'])
+        else:
+            in_x = x
+
+        with u.add_enabled_equivalencies(u.spectral() + u.temperature()):
+            freq = u.Quantity(in_x, u.Hz, dtype=np.float64)
+            temp = u.Quantity(in_temp, u.K)
+
+        if np.any(temp < 0):
+            raise ValueError(f"Temperature should be positive: {temp}")
+        if not np.all(np.isfinite(freq)) or np.any(freq <= 0):
+            warnings.warn(
+                "Input contains invalid wavelength/frequency value(s)",
+                AstropyUserWarning,
+            )
+
+        log_boltz = const.h * freq / (const.k_B * temp)
+        boltzm1 = np.expm1(log_boltz)
+
+        bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr
+
+        if hasattr(scale, 'unit'):
+            if not scale.unit.is_equivalent(u.dimensionless_unscaled):
+                scale = scale.to(u.dimensionless_unscaled).value
+            else:
+                scale = scale.value
+
+        y = scale * bb_nu.to(self._output_units, u.spectral_density(freq))
+
+        if hasattr(temperature, "unit"):
+            return y
+        return y.value
+
+    @property
+    def input_units(self):
+        if self._output_units.is_equivalent(self._native_output_units['SNU']):
+            return {self.inputs[0]: u.Hz}
+        else:
+            return {self.inputs[0]: u.AA}
+
+    def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):
+        return {"temperature": u.K}
+
+    @property
+    def bolometric_flux(self):
+        """Bolometric flux."""
+        if self.scale.unit is not None:
+            scale = self.scale.quantity.to(u.dimensionless_unscaled)
+        else:
+            scale = self.scale.value
+
+        native_bolflux = (
+            scale * const.sigma_sb * self.temperature ** 4 / np.pi
+        )
+        return native_bolflux.to(u.erg / (u.cm ** 2 * u.s))
+
+    @property
+    def lambda_max(self):
+        """Peak wavelength when the curve is expressed as power density."""
+        return const.b_wien / self.temperature
+
+    @property
+    def nu_max(self):
+        """Peak frequency when the curve is expressed as power density."""
+        return 2.8214391 * const.k_B * self.temperature / const.h
 
 
 class GPXBounds:
