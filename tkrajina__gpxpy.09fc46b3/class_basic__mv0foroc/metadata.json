{
  "cost": 0.011955760000000001,
  "explanation": "",
  "output": "```python\nclass GPXTrack:\n    gpx_10_fields = [\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('comment', 'cmt'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('source', 'src'),\n            mod_gpxfield.GPXField('link', 'url'),\n            mod_gpxfield.GPXField('link_text', 'urlname'),\n            mod_gpxfield.GPXField('number', type=mod_gpxfield.INT_TYPE),\n            mod_gpxfield.GPXComplexField('segments', tag='trkseg', classs=GPXTrackSegment, is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('comment', 'cmt'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('source', 'src'),\n            'link:@link',\n                mod_gpxfield.GPXField('link', attribute='href'),\n                mod_gpxfield.GPXField('link_text', tag='text'),\n                mod_gpxfield.GPXField('link_type', tag='type'),\n            '/link',\n            mod_gpxfield.GPXField('number', type=mod_gpxfield.INT_TYPE),\n            mod_gpxfield.GPXField('type'),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n            mod_gpxfield.GPXComplexField('segments', tag='trkseg', classs=GPXTrackSegment, is_list=True),\n    ]\n\n    __slots__ = ('name', 'comment', 'description', 'source', 'link',\n                 'link_text', 'number', 'segments', 'link_type', 'type',\n                 'extensions')\n\n    def __init__(self, name: Optional[str]=None, description: Optional[str]=None, number: Optional[int]=None) -> None:\n        self.name = name\n        self.comment: Optional[str] = None\n        self.description = description\n        self.source: Optional[str] = None\n        self.link: Optional[str] = None\n        self.link_text: Optional[str] = None\n        self.number = number\n        self.segments: List[GPXTrackSegment] = []\n        self.link_type = None\n        self.type = None\n        self.extensions: List[Any] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        for segment in self.segments:\n            segment.simplify(max_distance=max_distance)\n\n    def reduce_points(self, min_distance: float) -> None:\n        for segment in self.segments:\n            segment.reduce_points(min_distance)\n\n    def adjust_time(self, delta: mod_datetime.timedelta) -> None:\n        for segment in self.segments:\n            segment.adjust_time(delta)\n\n    def remove_time(self) -> None:\n        for segment in self.segments:\n            segment.remove_time()\n\n    def remove_elevation(self) -> None:\n        for segment in self.segments:\n            segment.remove_elevation()\n\n    def remove_empty(self) -> None:\n        result = []\n\n        for segment in self.segments:\n            if len(segment.points) > 1:\n                result.append(segment)\n\n        self.segments = result\n\n    def length_2d(self) -> float:\n        length: float = 0\n        for track_segment in self.segments:\n            d = track_segment.length_2d()\n            if d:\n                length += d\n        return length\n\n    def get_time_bounds(self) -> TimeBounds:\n        start_time = None\n        end_time = None\n\n        for track_segment in self.segments:\n            point_start_time, point_end_time = track_segment.get_time_bounds()\n            if not start_time and point_start_time:\n                start_time = point_start_time\n            if point_end_time:\n                end_time = point_end_time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        bounds: Optional[GPXBounds] = None\n        for track_segment in self.segments:\n            segment_bounds = track_segment.get_bounds()\n            if bounds is None:\n                bounds = segment_bounds\n            elif segment_bounds:\n                bounds = bounds.max_bounds(segment_bounds)\n\n        return bounds\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        for segment_no, segment in enumerate(self.segments if self.segments else []):\n            for point_no, point in enumerate(segment.points if segment.points else []):\n                if only_points:\n                    yield point\n                else:\n                    yield point, segment_no, point_no\n\n    def get_points_no(self) -> int:\n        result = 0\n\n        for track_segment in self.segments:\n            result += track_segment.get_points_no()\n\n        return result - 1\n\n    def length_3d(self) -> float:\n        length: float = 0\n        for track_segment in self.segments:\n            d = track_segment.length_3d()\n            if d:\n                length += d\n        return length\n\n    def split(self, track_segment_no: int, track_point_no: int) -> None:\n        new_segments = []\n        for i in range(len(self.segments)):\n            segment = self.segments[i]\n            if i == track_segment_no:\n                segment_1, segment_2 = segment.split(track_point_no)\n                if segment_1:\n                    new_segments.append(segment_1)\n                if segment_2:\n                    new_segments.append(segment_2)\n            else:\n                new_segments.append(segment)\n        self.segments = new_segments\n\n    def join(self, track_segment_no: int, track_segment_no_2: Optional[int]=None) -> None:\n        if not track_segment_no_2:\n            track_segment_no_2 = track_segment_no + 1\n\n        if track_segment_no_2 >= len(self.segments):\n            return\n\n        new_segments = []\n        for i in range(len(self.segments)):\n            segment = self.segments[i]\n            if i == track_segment_no:\n                second_segment = self.segments[track_segment_no_2]\n                segment.join(second_segment)\n\n                new_segments.append(segment)\n            elif i == track_segment_no_2:\n                pass\n            else:\n                new_segments.append(segment)\n        self.segments = new_segments\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool = True) -> MovingData:\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        max_speed = 0.\n\n        for segment in self.segments:\n            moving_data = segment.get_moving_data(stopped_speed_threshold, raw, speed_extreemes_percentiles, ignore_nonstandard_distances)\n            if moving_data:\n                moving_time += moving_data.moving_time\n                stopped_time += moving_data.stopped_time\n                moving_distance += moving_data.moving_distance\n                stopped_distance += moving_data.stopped_distance\n                if moving_data.max_speed is not None and moving_data.max_speed > max_speed:\n                    max_speed = moving_data.max_speed\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed)\n\n    def add_elevation(self, delta: float) -> None:\n        for track_segment in self.segments:\n            track_segment.add_elevation(delta)\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        for track_segment in self.segments:\n            track_segment.add_missing_data(get_data_function, add_missing_function)\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        for track_segment in self.segments:\n            track_segment.move(location_delta)\n\n    def get_duration(self) -> Optional[float]:\n        if not self.segments:\n            return 0.0\n\n        result = 0.\n        for track_segment in self.segments:\n            duration = track_segment.get_duration()\n            if duration or duration == 0:\n                result += duration\n            elif duration is None:\n                return None\n\n        return result\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        if not self.segments:\n            return UphillDownhill(0, 0)\n\n        uphill: float = 0\n        downhill: float = 0\n\n        for track_segment in self.segments:\n            current_uphill, current_downhill = track_segment.get_uphill_downhill()\n\n            uphill += current_uphill or .0\n            downhill += current_downhill or .0\n\n        return UphillDownhill(downhill, uphill)\n\n    def get_location_at(self, time: mod_datetime.datetime) -> List[GPXTrackPoint]:\n        result = []\n        for track_segment in self.segments:\n            location = track_segment.get_location_at(time)\n            if location:\n                result.append(location)\n\n        return result\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        if not self.segments:\n            return MinimumMaximum(None, None)\n\n        elevations = []\n\n        for track_segment in self.segments:\n            (_min, _max) = track_segment.get_elevation_extremes()\n            if _min is not None:\n                elevations.append(_min)\n            if _max is not None:\n                elevations.append(_max)\n\n        if len(elevations) == 0:\n            return MinimumMaximum(None, None)\n\n        return MinimumMaximum(max(elevations), min(elevations))\n\n    def get_center(self) -> Optional[mod_geo.Location]:\n        if not self.segments:\n            return None\n        sum_lat: float = 0\n        sum_lon: float = 0\n        n = 0\n        for track_segment in self.segments:\n            for point in track_segment.points:\n                n += 1\n                sum_lat += point.latitude\n                sum_lon += point.longitude\n\n        if not n:\n            return mod_geo.Location(0, 0)\n\n        return mod_geo.Location(latitude=sum_lat / n, longitude=sum_lon / n)\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        for track_segment in self.segments:\n            track_segment.smooth(vertical, horizontal, remove_extremes)\n\n    def has_times(self) -> bool:\n        if not self.segments:\n            return False\n\n        for track_segment in self.segments:\n            if track_segment.has_times():\n                return True\n\n        return False\n\n    def has_elevations(self) -> bool:\n        if not self.segments:\n            return False\n\n        result = True\n        for track_segment in self.segments:\n            result = result and track_segment.has_elevations()\n\n        return result\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        return min((NearestLocationData(pt, -1, seg, pt_no) for (pt, seg, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n        \n    def clone(self) -> \"GPXTrack\":\n        return mod_copy.deepcopy(self)\n\n    def __repr__(self) -> str:\n        parts = []\n        for attribute in 'description', 'number':\n            value = getattr(self, attribute)\n            if value is not None:\n                parts.append(f'{attribute}={value!r}')\n        parts.append(f'segments={self.segments!r}')\n        return f'GPXTrack({\", \".join(parts)})'\n```",
  "rewrite": "class GPXTrack:\n    gpx_10_fields = [\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('comment', 'cmt'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('source', 'src'),\n            mod_gpxfield.GPXField('link', 'url'),\n            mod_gpxfield.GPXField('link_text', 'urlname'),\n            mod_gpxfield.GPXField('number', type=mod_gpxfield.INT_TYPE),\n            mod_gpxfield.GPXComplexField('segments', tag='trkseg', classs=GPXTrackSegment, is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('comment', 'cmt'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('source', 'src'),\n            'link:@link',\n                mod_gpxfield.GPXField('link', attribute='href'),\n                mod_gpxfield.GPXField('link_text', tag='text'),\n                mod_gpxfield.GPXField('link_type', tag='type'),\n            '/link',\n            mod_gpxfield.GPXField('number', type=mod_gpxfield.INT_TYPE),\n            mod_gpxfield.GPXField('type'),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n            mod_gpxfield.GPXComplexField('segments', tag='trkseg', classs=GPXTrackSegment, is_list=True),\n    ]\n\n    __slots__ = ('name', 'comment', 'description', 'source', 'link',\n                 'link_text', 'number', 'segments', 'link_type', 'type',\n                 'extensions')\n\n    def __init__(self, name: Optional[str]=None, description: Optional[str]=None, number: Optional[int]=None) -> None:\n        self.name = name\n        self.comment: Optional[str] = None\n        self.description = description\n        self.source: Optional[str] = None\n        self.link: Optional[str] = None\n        self.link_text: Optional[str] = None\n        self.number = number\n        self.segments: List[GPXTrackSegment] = []\n        self.link_type = None\n        self.type = None\n        self.extensions: List[Any] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        for segment in self.segments:\n            segment.simplify(max_distance=max_distance)\n\n    def reduce_points(self, min_distance: float) -> None:\n        for segment in self.segments:\n            segment.reduce_points(min_distance)\n\n    def adjust_time(self, delta: mod_datetime.timedelta) -> None:\n        for segment in self.segments:\n            segment.adjust_time(delta)\n\n    def remove_time(self) -> None:\n        for segment in self.segments:\n            segment.remove_time()\n\n    def remove_elevation(self) -> None:\n        for segment in self.segments:\n            segment.remove_elevation()\n\n    def remove_empty(self) -> None:\n        result = []\n\n        for segment in self.segments:\n            if len(segment.points) > 1:\n                result.append(segment)\n\n        self.segments = result\n\n    def length_2d(self) -> float:\n        length: float = 0\n        for track_segment in self.segments:\n            d = track_segment.length_2d()\n            if d:\n                length += d\n        return length\n\n    def get_time_bounds(self) -> TimeBounds:\n        start_time = None\n        end_time = None\n\n        for track_segment in self.segments:\n            point_start_time, point_end_time = track_segment.get_time_bounds()\n            if not start_time and point_start_time:\n                start_time = point_start_time\n            if point_end_time:\n                end_time = point_end_time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        bounds: Optional[GPXBounds] = None\n        for track_segment in self.segments:\n            segment_bounds = track_segment.get_bounds()\n            if bounds is None:\n                bounds = segment_bounds\n            elif segment_bounds:\n                bounds = bounds.max_bounds(segment_bounds)\n\n        return bounds\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        for segment_no, segment in enumerate(self.segments if self.segments else []):\n            for point_no, point in enumerate(segment.points if segment.points else []):\n                if only_points:\n                    yield point\n                else:\n                    yield point, segment_no, point_no\n\n    def get_points_no(self) -> int:\n        result = 0\n\n        for track_segment in self.segments:\n            result += track_segment.get_points_no()\n\n        return result - 1\n\n    def length_3d(self) -> float:\n        length: float = 0\n        for track_segment in self.segments:\n            d = track_segment.length_3d()\n            if d:\n                length += d\n        return length\n\n    def split(self, track_segment_no: int, track_point_no: int) -> None:\n        new_segments = []\n        for i in range(len(self.segments)):\n            segment = self.segments[i]\n            if i == track_segment_no:\n                segment_1, segment_2 = segment.split(track_point_no)\n                if segment_1:\n                    new_segments.append(segment_1)\n                if segment_2:\n                    new_segments.append(segment_2)\n            else:\n                new_segments.append(segment)\n        self.segments = new_segments\n\n    def join(self, track_segment_no: int, track_segment_no_2: Optional[int]=None) -> None:\n        if not track_segment_no_2:\n            track_segment_no_2 = track_segment_no + 1\n\n        if track_segment_no_2 >= len(self.segments):\n            return\n\n        new_segments = []\n        for i in range(len(self.segments)):\n            segment = self.segments[i]\n            if i == track_segment_no:\n                second_segment = self.segments[track_segment_no_2]\n                segment.join(second_segment)\n\n                new_segments.append(segment)\n            elif i == track_segment_no_2:\n                pass\n            else:\n                new_segments.append(segment)\n        self.segments = new_segments\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool = True) -> MovingData:\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        max_speed = 0.\n\n        for segment in self.segments:\n            moving_data = segment.get_moving_data(stopped_speed_threshold, raw, speed_extreemes_percentiles, ignore_nonstandard_distances)\n            if moving_data:\n                moving_time += moving_data.moving_time\n                stopped_time += moving_data.stopped_time\n                moving_distance += moving_data.moving_distance\n                stopped_distance += moving_data.stopped_distance\n                if moving_data.max_speed is not None and moving_data.max_speed > max_speed:\n                    max_speed = moving_data.max_speed\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed)\n\n    def add_elevation(self, delta: float) -> None:\n        for track_segment in self.segments:\n            track_segment.add_elevation(delta)\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        for track_segment in self.segments:\n            track_segment.add_missing_data(get_data_function, add_missing_function)\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        for track_segment in self.segments:\n            track_segment.move(location_delta)\n\n    def get_duration(self) -> Optional[float]:\n        if not self.segments:\n            return 0.0\n\n        result = 0.\n        for track_segment in self.segments:\n            duration = track_segment.get_duration()\n            if duration or duration == 0:\n                result += duration\n            elif duration is None:\n                return None\n\n        return result\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        if not self.segments:\n            return UphillDownhill(0, 0)\n\n        uphill: float = 0\n        downhill: float = 0\n\n        for track_segment in self.segments:\n            current_uphill, current_downhill = track_segment.get_uphill_downhill()\n\n            uphill += current_uphill or .0\n            downhill += current_downhill or .0\n\n        return UphillDownhill(downhill, uphill)\n\n    def get_location_at(self, time: mod_datetime.datetime) -> List[GPXTrackPoint]:\n        result = []\n        for track_segment in self.segments:\n            location = track_segment.get_location_at(time)\n            if location:\n                result.append(location)\n\n        return result\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        if not self.segments:\n            return MinimumMaximum(None, None)\n\n        elevations = []\n\n        for track_segment in self.segments:\n            (_min, _max) = track_segment.get_elevation_extremes()\n            if _min is not None:\n                elevations.append(_min)\n            if _max is not None:\n                elevations.append(_max)\n\n        if len(elevations) == 0:\n            return MinimumMaximum(None, None)\n\n        return MinimumMaximum(max(elevations), min(elevations))\n\n    def get_center(self) -> Optional[mod_geo.Location]:\n        if not self.segments:\n            return None\n        sum_lat: float = 0\n        sum_lon: float = 0\n        n = 0\n        for track_segment in self.segments:\n            for point in track_segment.points:\n                n += 1\n                sum_lat += point.latitude\n                sum_lon += point.longitude\n\n        if not n:\n            return mod_geo.Location(0, 0)\n\n        return mod_geo.Location(latitude=sum_lat / n, longitude=sum_lon / n)\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        for track_segment in self.segments:\n            track_segment.smooth(vertical, horizontal, remove_extremes)\n\n    def has_times(self) -> bool:\n        if not self.segments:\n            return False\n\n        for track_segment in self.segments:\n            if track_segment.has_times():\n                return True\n\n        return False\n\n    def has_elevations(self) -> bool:\n        if not self.segments:\n            return False\n\n        result = True\n        for track_segment in self.segments:\n            result = result and track_segment.has_elevations()\n\n        return result\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        return min((NearestLocationData(pt, -1, seg, pt_no) for (pt, seg, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n        \n    def clone(self) -> \"GPXTrack\":\n        return mod_copy.deepcopy(self)\n\n    def __repr__(self) -> str:\n        parts = []\n        for attribute in 'description', 'number':\n            value = getattr(self, attribute)\n            if value is not None:\n                parts.append(f'{attribute}={value!r}')\n        parts.append(f'segments={self.segments!r}')\n        return f'GPXTrack({\", \".join(parts)})'",
  "strategy": "llm"
}