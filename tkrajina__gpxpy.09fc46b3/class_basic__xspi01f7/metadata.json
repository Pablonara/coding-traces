{
  "cost": 0.00500478,
  "explanation": "",
  "output": "```python\ndef distance(latitude_1: float, longitude_1: float, elevation_1: Optional[float],\n            latitude_2: float, longitude_2: float, elevation_2: Optional[float],\n            haversine: bool=False) -> float:\n    \"\"\"\n    Distance between two points. If elevation is None compute a 2d distance\n\n    if haversine==True -- haversine will be used for every computations,\n    otherwise...\n\n    Haversine distance will be used for distant points where elevation makes a\n    small difference, so it is ignored. That's because haversine is 5-6 times\n    slower than the dummy distance algorithm (which is OK for most GPS tracks).\n    \"\"\"\n\n    # If points too distant -- compute haversine distance:\n    if haversine or (abs(latitude_1 - latitude_2) > .1 or abs(longitude_1 - longitude_2) > .1):\n        return haversine_distance(latitude_1, longitude_1, latitude_2, longitude_2)\n\n    coef = mod_math.cos(mod_math.radians((latitude_1 + latitude_2) / 2))\n    x = latitude_1 - latitude_2\n    y = (longitude_1 - longitude_2) * coef\n\n    distance_2d = mod_math.sqrt(x * x + y * y) * ONE_DEGREE\n\n    if elevation_1 is None or elevation_2 is None:\n        return distance_2d\n\n    elevation_diff = elevation_1 - elevation_2\n    return mod_math.sqrt(distance_2d ** 2 + elevation_diff * elevation_diff)\n```",
  "rewrite": "def distance(latitude_1: float, longitude_1: float, elevation_1: Optional[float],\n            latitude_2: float, longitude_2: float, elevation_2: Optional[float],\n            haversine: bool=False) -> float:\n    \"\"\"\n    Distance between two points. If elevation is None compute a 2d distance\n\n    if haversine==True -- haversine will be used for every computations,\n    otherwise...\n\n    Haversine distance will be used for distant points where elevation makes a\n    small difference, so it is ignored. That's because haversine is 5-6 times\n    slower than the dummy distance algorithm (which is OK for most GPS tracks).\n    \"\"\"\n\n    # If points too distant -- compute haversine distance:\n    if haversine or (abs(latitude_1 - latitude_2) > .1 or abs(longitude_1 - longitude_2) > .1):\n        return haversine_distance(latitude_1, longitude_1, latitude_2, longitude_2)\n\n    coef = mod_math.cos(mod_math.radians((latitude_1 + latitude_2) / 2))\n    x = latitude_1 - latitude_2\n    y = (longitude_1 - longitude_2) * coef\n\n    distance_2d = mod_math.sqrt(x * x + y * y) * ONE_DEGREE\n\n    if elevation_1 is None or elevation_2 is None:\n        return distance_2d\n\n    elevation_diff = elevation_1 - elevation_2\n    return mod_math.sqrt(distance_2d ** 2 + elevation_diff * elevation_diff)",
  "strategy": "llm"
}