{
  "cost": 0.00405809,
  "explanation": "",
  "output": "```python\nclass LocationDelta:\n    \"\"\"\n    Intended to use similar to timestamp.timedelta, but for Locations.\n    \"\"\"\n\n    NORTH = 0\n    EAST = 90\n    SOUTH = 180\n    WEST = 270\n\n    def __init__(self, distance: Optional[float]=None, angle: Optional[float]=None,\n                 latitude_diff: Optional[float]=None,longitude_diff: Optional[float]=None) -> None:\n        \"\"\"\n        Version 1:\n            Distance (in meters).\n            angle_from_north *clockwise*.\n            ...must be given\n        Version 2:\n            latitude_diff and longitude_diff\n            ...must be given\n        \"\"\"\n        if (distance is not None) and (angle is not None):\n            if (latitude_diff is not None) or (longitude_diff is not None):\n                raise Exception('No lat/lon diff if using distance and angle!')\n            self.distance = distance\n            self.angle_from_north = angle\n            self.move_function = self.move_by_angle_and_distance\n        elif (latitude_diff is not None) or (longitude_diff is not None):\n            if (distance is not None) or (angle is not None):\n                raise Exception('No distance/angle if using lat/lon diff!')\n            self.latitude_diff  = latitude_diff\n            self.longitude_diff = longitude_diff\n            self.move_function = self.move_by_lat_lon_diff\n\n    def move(self, location: Location) -> Tuple[float, float]:\n        \"\"\"\n        Move location by this LocationDelta.\n        \"\"\"\n        return self.move_function(location)\n\n    def move_by_angle_and_distance(self, location: Location) -> Tuple[float, float]:\n        coef = mod_math.cos(mod_math.radians(location.latitude))\n        vertical_distance_diff   = mod_math.sin(mod_math.radians(self.angle_from_north)) / ONE_DEGREE\n        horizontal_distance_diff = mod_math.cos(mod_math.radians(self.angle_from_north)) / ONE_DEGREE\n        lat_diff = self.distance * vertical_distance_diff\n        lon_diff = self.distance * horizontal_distance_diff / coef\n        return location.latitude + lat_diff, location.longitude + lon_diff\n\n    def move_by_lat_lon_diff(self, location: \"Location\") -> Tuple[float, float]:\n        return location.latitude + self.latitude_diff, location.longitude + self.longitude_diff\n\n    def __repr__(self) -> str:\n        if hasattr(self, 'distance'):\n            return f'LocationDelta: {self.distance}, {self.angle_from_north}, {None}, {None}'\n        return f'LocationDelta: {None}, {None}, {self.latitude_diff}, {self.longitude_diff}'\n\n    def __str__(self) -> str:\n        if hasattr(self, 'distance'):\n            return f'LocationDelta(distance={self.distance}, ' \\\n                   f'angle={self.angle_from_north})'\n        return f'LocationDelta(latitude_diff={self.latitude_diff}, ' \\\n               f'longitude_diff={self.longitude_diff})'\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        if (hasattr(self, 'distance') and not hasattr(other, 'distance')) \\\n                or (not hasattr(self, \"distance\") and hasattr(other, \"distance\")):\n            return False\n        if hasattr(self, 'distance'):\n            return self.distance == other.distance and self.angle_from_north == other.angle_from_north\n        return self.latitude_diff == other.latitude_diff and self.longitude_diff == other.longitude_diff\n```",
  "rewrite": "class LocationDelta:\n    \"\"\"\n    Intended to use similar to timestamp.timedelta, but for Locations.\n    \"\"\"\n\n    NORTH = 0\n    EAST = 90\n    SOUTH = 180\n    WEST = 270\n\n    def __init__(self, distance: Optional[float]=None, angle: Optional[float]=None,\n                 latitude_diff: Optional[float]=None,longitude_diff: Optional[float]=None) -> None:\n        \"\"\"\n        Version 1:\n            Distance (in meters).\n            angle_from_north *clockwise*.\n            ...must be given\n        Version 2:\n            latitude_diff and longitude_diff\n            ...must be given\n        \"\"\"\n        if (distance is not None) and (angle is not None):\n            if (latitude_diff is not None) or (longitude_diff is not None):\n                raise Exception('No lat/lon diff if using distance and angle!')\n            self.distance = distance\n            self.angle_from_north = angle\n            self.move_function = self.move_by_angle_and_distance\n        elif (latitude_diff is not None) or (longitude_diff is not None):\n            if (distance is not None) or (angle is not None):\n                raise Exception('No distance/angle if using lat/lon diff!')\n            self.latitude_diff  = latitude_diff\n            self.longitude_diff = longitude_diff\n            self.move_function = self.move_by_lat_lon_diff\n\n    def move(self, location: Location) -> Tuple[float, float]:\n        \"\"\"\n        Move location by this LocationDelta.\n        \"\"\"\n        return self.move_function(location)\n\n    def move_by_angle_and_distance(self, location: Location) -> Tuple[float, float]:\n        coef = mod_math.cos(mod_math.radians(location.latitude))\n        vertical_distance_diff   = mod_math.sin(mod_math.radians(self.angle_from_north)) / ONE_DEGREE\n        horizontal_distance_diff = mod_math.cos(mod_math.radians(self.angle_from_north)) / ONE_DEGREE\n        lat_diff = self.distance * vertical_distance_diff\n        lon_diff = self.distance * horizontal_distance_diff / coef\n        return location.latitude + lat_diff, location.longitude + lon_diff\n\n    def move_by_lat_lon_diff(self, location: \"Location\") -> Tuple[float, float]:\n        return location.latitude + self.latitude_diff, location.longitude + self.longitude_diff\n\n    def __repr__(self) -> str:\n        if hasattr(self, 'distance'):\n            return f'LocationDelta: {self.distance}, {self.angle_from_north}, {None}, {None}'\n        return f'LocationDelta: {None}, {None}, {self.latitude_diff}, {self.longitude_diff}'\n\n    def __str__(self) -> str:\n        if hasattr(self, 'distance'):\n            return f'LocationDelta(distance={self.distance}, ' \\\n                   f'angle={self.angle_from_north})'\n        return f'LocationDelta(latitude_diff={self.latitude_diff}, ' \\\n               f'longitude_diff={self.longitude_diff})'\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        if (hasattr(self, 'distance') and not hasattr(other, 'distance')) \\\n                or (not hasattr(self, \"distance\") and hasattr(other, \"distance\")):\n            return False\n        if hasattr(self, 'distance'):\n            return self.distance == other.distance and self.angle_from_north == other.angle_from_north\n        return self.latitude_diff == other.latitude_diff and self.longitude_diff == other.longitude_diff",
  "strategy": "llm"
}