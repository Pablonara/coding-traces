{
  "cost": 0.01865069,
  "explanation": "",
  "output": "```python\nclass GPXTrackSegment:\n    gpx_10_fields = [\n            mod_gpxfield.GPXComplexField('points', tag='trkpt', classs=GPXTrackPoint, is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXComplexField('points', tag='trkpt', classs=GPXTrackPoint, is_list=True),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n    ]\n\n    __slots__ = ('points', 'extensions', )\n\n    def __init__(self, points: Optional[List[GPXTrackPoint]]=None) -> None:\n        self.points: List[GPXTrackPoint] = points if points else []\n        self.extensions: List[Any] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        \"\"\"\n        Simplify using the Ramer-Douglas-Peucker algorithm: http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n        \"\"\"\n        self.points = mod_geo.simplify_polyline(self.points, max_distance) # type: ignore\n\n    def reduce_points(self, min_distance: float) -> None:\n        \"\"\"\n        Reduces the number of points in the track segment. Segment points will\n        be updated in place.\n\n        Parameters\n        ----------\n        min_distance : float\n            The minimum separation in meters between points\n        \"\"\"\n        reduced_points: List[GPXTrackPoint] = []\n        for point in self.points:\n            if reduced_points:\n                distance = reduced_points[-1].distance_3d(point)\n                if min_distance is not None and distance is not None and distance > min_distance:\n                    reduced_points.append(point)\n            else:\n                reduced_points.append(point)\n\n        self.points = reduced_points\n\n    def adjust_time(self, delta: mod_datetime.timedelta) -> None:\n        \"\"\"\n        Adjusts the time of all points in the segment by the specified delta\n\n        Parameters\n        ----------\n        delta : datetime.timedelta\n            Positive time delta will adjust point times into the future\n            Negative time delta will adjust point times into the past\n        \"\"\"\n        for track_point in self.points:\n            track_point.adjust_time(delta)\n\n    def remove_time(self) -> None:\n        \"\"\" Removes time data for all points in the segment. \"\"\"\n        for track_point in self.points:\n            track_point.remove_time()\n\n    def remove_elevation(self) -> None:\n        \"\"\" Removes elevation data for all points in the segment. \"\"\"\n        for track_point in self.points:\n            track_point.remove_elevation()\n\n    def length_2d(self) -> Optional[float]:\n        \"\"\"\n        Computes 2-dimensional length (meters) of segment (only latitude and\n        longitude, no elevation).\n\n        Returns\n        ----------\n        length : float\n            Length returned in meters\n        \"\"\"\n        return mod_geo.length_2d(self.points) # type: ignore\n\n    def length_3d(self) -> float:\n        \"\"\"\n        Computes 3-dimensional length of segment (latitude, longitude, and\n        elevation).\n\n        Returns\n        ----------\n        length : float\n            Length returned in meters\n        \"\"\"\n        return mod_geo.length_3d(self.points) # type: ignore\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        \"\"\"\n        Moves each point in the segment.\n\n        Parameters\n        ----------\n        location_delta: LocationDelta object\n            Delta (distance/angle or lat/lon offset to apply each point in the\n            segment\n        \"\"\"\n        for track_point in self.points:\n            track_point.move(location_delta)\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        \"\"\"\n        Generator for iterating over segment points\n\n        Parameters\n        ----------\n        only_points: boolean\n            Only yield points (no index yielded)\n\n        Yields\n        ------\n        point: GPXTrackPoint\n            A point in the sement\n        point_no: int\n            Not included in yield if only_points is true\n        \"\"\"\n        for point_no, point in enumerate(self.points if self.points else []):\n            if only_points:\n                yield point\n            else:\n                yield point, point_no\n\n    def get_points_no(self) -> int:\n        \"\"\"\n        Gets the number of points in segment.\n\n        Returns\n        ----------\n        num_points : integer\n            Number of points in segment\n        \"\"\"\n        if not self.points:\n            return 0\n        return len(self.points)\n\n    def split(self, point_no: int) -> Tuple[\"GPXTrackSegment\", \"GPXTrackSegment\"]:\n        \"\"\"\n        Splits the segment into two parts.\n\n        Parameters\n        ----------\n        point_no : integer\n            The index of the track point in the segment to split\n        \"\"\"\n        part_1 = self.points[:point_no + 1]\n        part_2 = self.points[point_no:]\n        return GPXTrackSegment(part_1), GPXTrackSegment(part_2)\n\n    def join(self, track_segment: \"GPXTrackSegment\") -> None:\n        \"\"\" Joins with another segment \"\"\"\n        self.points += track_segment.points\n\n    def remove_point(self, point_no: int) -> None:\n        \"\"\" Removes a point specified by index from the segment \"\"\"\n        if point_no < 0 or point_no >= len(self.points):\n            return\n\n        part_1 = self.points[:point_no]\n        part_2 = self.points[point_no + 1:]\n\n        self.points = part_1 + part_2\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool = True) -> Optional[MovingData]:\n        \"\"\"\n        Return a tuple of (moving_time, stopped_time, moving_distance,\n        stopped_distance, max_speed) that may be used for detecting the time\n        stopped, and max speed. Not that those values are not absolutely true,\n        because the \"stopped\" or \"moving\" information aren't saved in the segment.\n\n        Because of errors in the GPS recording, it may be good to calculate\n        them on a reduced and smoothed version of the track.\n\n        Parameters\n        ----------\n        stopped_speed_threshold : float\n            speeds (km/h) below this threshold are treated as if having no\n            movement. Default is 1 km/h.\n\n        Returns\n        ----------\n        moving_data : MovingData : named tuple\n            moving_time : float\n                time (seconds) of segment in which movement was occurring\n            stopped_time : float\n                time (seconds) of segment in which no movement was occurring\n            stopped_distance : float\n                distance (meters) travelled during stopped times\n            moving_distance : float\n                distance (meters) travelled during moving times\n            max_speed : float\n                Maximum speed (m/s) during the segment.\n        \"\"\"\n        if not stopped_speed_threshold:\n            stopped_speed_threshold = DEFAULT_STOPPED_SPEED_THRESHOLD\n\n        if raw:\n            speed_extreemes_percentiles=0\n            ignore_nonstandard_distances=False\n\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        speeds_and_distances = []\n\n        for previous, point in zip(self.points, self.points[1:]):\n\n            if point.time and previous.time:\n                timedelta = point.time - previous.time\n\n                if point.elevation and previous.elevation:\n                    distance = point.distance_3d(previous)\n                else:\n                    distance = point.distance_2d(previous)\n\n                seconds = mod_utils.total_seconds(timedelta)\n                speed_kmh: float = 0\n                if seconds > 0 and distance is not None:\n                    speed_kmh = (distance / 1000) / (seconds / 60 ** 2)\n                    if distance:\n                        if speed_kmh <= stopped_speed_threshold:\n                            stopped_time += seconds\n                            stopped_distance += distance\n                        else:\n                            moving_time += seconds\n                            moving_distance += distance\n                        if moving_time:\n                            speeds_and_distances.append((distance / seconds, distance, ))\n\n        max_speed = None\n        if speeds_and_distances:\n            max_speed = mod_geo.calculate_max_speed(speeds_and_distances, speed_extreemes_percentiles, ignore_nonstandard_distances)\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed or 0.0)\n\n    def get_time_bounds(self) -> TimeBounds:\n        \"\"\"\n        Gets the time bound (start and end) of the segment.\n\n        returns\n        ----------\n        time_bounds : TimeBounds named tuple\n            start_time : datetime\n                Start time of the first segment in track\n            end time : datetime\n                End time of the last segment in track\n        \"\"\"\n        start_time = None\n        end_time = None\n\n        for point in self.points:\n            if point.time:\n                if not start_time:\n                    start_time = point.time\n                if point.time and (not end_time or point.time > end_time):\n                    end_time = point.time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        \"\"\"\n        Gets the latitude and longitude bounds of the segment.\n\n        Returns\n        ----------\n        bounds : Bounds named tuple\n            min_latitude : float\n                Minimum latitude of segment in decimal degrees [-90, 90]\n            max_latitude : float\n                Maximum latitude of segment in decimal degrees [-90, 90]\n            min_longitude : float\n                Minimum longitude of segment in decimal degrees [-180, 180]\n            max_longitude : float\n                Maximum longitude of segment in decimal degrees [-180, 180]\n        \"\"\"\n        min_lat = None\n        max_lat = None\n        min_lon = None\n        max_lon = None\n\n        for point in self.points:\n            if min_lat is None or point.latitude < min_lat:\n                min_lat = point.latitude\n            if max_lat is None or point.latitude > max_lat:\n                max_lat = point.latitude\n            if min_lon is None or point.longitude > min_lon:\n                min_lon = point.longitude\n            if max_lon is None or point.longitude < max_lon:\n                max_lon = point.longitude\n\n        if min_lat and max_lat and min_lon and max_lon:\n            return GPXBounds(min_lat, max_lat, min_lon, max_lon)\n        return None\n\n    def get_speed(self, point_no: int) -> Optional[float]:\n        \"\"\"\n        Computes the speed at the specified point index.\n\n        Parameters\n        ----------\n        point_no : integer\n            index of the point used to compute speed\n\n        Returns\n        ----------\n        speed : float\n            Speed returned in m/s\n        \"\"\"\n        point = self.points[point_no]\n\n        previous_point = None\n        next_point = None\n\n        if 0 < point_no < len(self.points):\n            previous_point = self.points[point_no - 1]\n        if 0 <= point_no < len(self.points) - 1:\n            next_point = self.points[point_no + 1]\n\n        speed_1 = point.speed_between(previous_point) if previous_point else None\n        speed_2 = point.speed_between(next_point) if next_point else None\n\n        if speed_1:\n            speed_1 = abs(speed_1)\n        if speed_2:\n            speed_2 = abs(speed_2)\n\n        if speed_1 and speed_2:\n            return max(speed_1, speed_2)\n\n        if speed_1:\n            return speed_1\n\n        return speed_2\n\n    def add_elevation(self, delta: float) -> None:\n        \"\"\"\n        Adjusts elevation data for segment.\n\n        Parameters\n        ----------\n        delta : float\n            Elevation delta in meters to apply to track\n        \"\"\"\n        log.debug('delta = %s', delta)\n\n        if not delta:\n            return\n\n        for track_point in self.points:\n            if track_point.elevation is not None:\n                track_point.elevation += delta\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        \"\"\"\n        Calculate missing data.\n\n        Parameters\n        ----------\n        get_data_function : object\n            Returns the data from point\n        add_missing_function : void\n            Function with the following arguments: array with points with missing data, the point before them (with data),\n            the point after them (with data), and distance ratios between points in the interval (the sum of distances ratios\n            will be 1)\n        \"\"\"\n        if not get_data_function:\n            raise GPXException(f'Invalid get_data_function: {get_data_function}')\n        if not add_missing_function:\n            raise GPXException(f'Invalid add_missing_function: {add_missing_function}')\n\n        interval: List[GPXTrackPoint] = []\n        start_point = None\n\n        previous_point = None\n        for track_point in self.points:\n            data = get_data_function(track_point)\n            if data is None and previous_point:\n                if not start_point:\n                    start_point = previous_point\n                interval.append(track_point)\n            else:\n                if interval and start_point:\n                    distances_ratios = self._get_interval_distances_ratios(interval, start_point, track_point)\n                    add_missing_function(interval, start_point, track_point, distances_ratios)\n                    start_point = None\n                    interval = []\n            previous_point = track_point\n\n    def _get_interval_distances_ratios(self, interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint) -> List[float]:\n        assert start, start\n        assert end, end\n        assert interval, interval\n        assert len(interval) > 0, interval\n\n        distances = []\n        distance_from_start: float = 0\n        previous_point = start\n        for point in interval:\n            dist = point.distance_3d(previous_point)\n            if dist is not None:\n                distance_from_start += dist\n                distances.append(distance_from_start)\n                previous_point = point\n\n        dist = interval[-1].distance_3d(end)\n        from_start_to_end = None\n        if dist:\n            from_start_to_end = distances[-1] + dist\n\n        assert len(interval) == len(distances)\n\n        return [(distance / from_start_to_end) if from_start_to_end else 0\n                for distance in distances]\n\n    def get_duration(self) -> Optional[float]:\n        \"\"\"\n        Calculates duration or track segment\n\n        Returns\n        -------\n        duration: float\n            Duration in seconds\n        \"\"\"\n        if not self.points or len(self.points) < 2:\n            return 0.0\n\n        first = self.points[0]\n        if not first.time:\n            first = self.points[1]\n\n        last = self.points[-1]\n        if not last.time:\n            last = self.points[-2]\n\n        if not last.time or not first.time:\n            log.debug('Can\\'t find time')\n            return None\n\n        if last.time < first.time:\n            log.debug('Not enough time data')\n            return None\n\n        return mod_utils.total_seconds(last.time - first.time)\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        \"\"\"\n        Calculates the uphill and downhill elevation climbs for the track\n        segment. If elevation for some points is not found those are simply\n        ignored.\n\n        Returns\n        -------\n        uphill_downhill: UphillDownhill named tuple\n            uphill: float\n                Uphill elevation climbs in meters\n            downhill: float\n                Downhill elevation descent in meters\n        \"\"\"\n        if not self.points:\n            return UphillDownhill(0, 0)\n\n        elevations = [point.elevation for point in self.points]\n        uphill, downhill = mod_geo.calculate_uphill_downhill(elevations)\n\n        return UphillDownhill(downhill, uphill)\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        \"\"\"\n        Calculate elevation extremes of track segment\n\n        Returns\n        -------\n        min_max_elevation: MinimumMaximum named tuple\n            minimum: float\n                Minimum elevation in meters\n            maximum: float\n                Maximum elevation in meters\n        \"\"\"\n        if not self.points:\n            return MinimumMaximum(None, None)\n\n        elevations = [x.elevation for x in self.points if x.elevation is not None]\n        if not elevations:\n            return MinimumMaximum(None, None)\n        return MinimumMaximum(max(elevations), min(elevations))\n\n    def get_location_at(self, time: mod_datetime.datetime) -> Optional[GPXTrackPoint]:\n        \"\"\"\n        Gets approx. location at given time. Note that, at the moment this\n        method returns an instance of GPXTrackPoint in the future -- this may\n        be a mod_geo.Location instance with approximated latitude, longitude\n        and elevation!\n        \"\"\"\n        if not self.points:\n            return None\n\n        if not time:\n            return None\n\n        first_time = self.points[0].time\n        last_time = self.points[-1].time\n\n        if not first_time and not last_time:\n            log.debug('No times for track segment')\n            return None\n\n        if first_time and time and last_time and not first_time <= time <= last_time:\n            log.debug(f'Not in track (search for:{time}, start:{first_time}, end:{last_time})')\n            return None\n\n        for point in self.points:\n            if point.time and time < point.time:\n                return point\n        \n        return None\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        \"\"\" Return the (location, track_point_no) on this track segment \"\"\"\n        return min((NearestLocationData(pt, -1, -1, pt_no) for (pt, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        \"\"\" \"Smooths\" the elevation graph. Can be called multiple times. \"\"\"\n        if len(self.points) <= 3:\n            return\n\n        elevations: List[float] = []\n        latitudes: List[float] = []\n        longitudes: List[float] = []\n\n        for point in self.points:\n            elevations.append(point.elevation or 0)\n            latitudes.append(point.latitude or 0)\n            longitudes.append(point.longitude or 0)\n\n        avg_distance: float = 0\n        avg_elevation_delta: float = 1\n        if remove_extremes:\n            distances: List[float] = []\n            elevations_delta = []\n            for prev, cur in zip(self.points, self.points[1:]):\n                dist = prev.distance_2d(cur)\n                if dist:\n                    distances.append(dist)\n                if cur.elevation is not None and prev.elevation is not None:\n                    elevations_delta.append(abs(cur.elevation - prev.elevation))\n            if distances:\n                avg_distance = 1.0 * sum(distances) / len(distances)\n            if elevations_delta:\n                avg_elevation_delta = 1.0 * sum(elevations_delta) / len(elevations_delta)\n\n        remove_2d_extremes_threshold = 1.75 * avg_distance\n        remove_elevation_extremes_threshold = avg_elevation_delta * 5\n\n        new_track_points = [self.points[0]]\n\n        for i in range(len(self.points))[1:-1]:\n            new_point = None\n            point_removed = False\n            if vertical and elevations[i - 1] and elevations[i] and elevations[i + 1]:\n                old_elevation = self.points[i].elevation\n                new_elevation = 0.4 * elevations[i - 1] + \\\n                    0.2 * elevations[i] + \\\n                    0.4 * elevations[i + 1]\n\n                if not remove_extremes:\n                    self.points[i].elevation = new_elevation\n\n                if remove_extremes:\n                    d1 = abs((old_elevation or 0) - elevations[i - 1])\n                    d2 = abs((old_elevation or 0) - elevations[i + 1])\n\n                    if min(d1, d2) < remove_elevation_extremes_threshold and abs((old_elevation or 0) - (new_elevation or 0)) < remove_2d_extremes_threshold:\n                        new_point = self.points[i]\n                    else:\n                        point_removed = True\n                else:\n                    new_point = self.points[i]\n            else:\n                new_point = self.points[i]\n\n            if horizontal:\n                old_latitude = self.points[i].latitude\n                new_latitude = 0.4 * latitudes[i - 1] + \\\n                    0.2 * latitudes[i] + \\\n                    0.4 * latitudes[i + 1]\n                old_longitude = self.points[i].longitude\n                new_longitude = 0.4 * longitudes[i - 1] + \\\n                    0.2 * longitudes[i] + \\\n                    0.4 * longitudes[i + 1]\n\n                if not remove_extremes:\n                    self.points[i].latitude = new_latitude\n                    self.points[i].longitude = new_longitude\n\n                d1 = mod_geo.distance(latitudes[i - 1], longitudes[i - 1], None, latitudes[i], longitudes[i], None)\n                d2 = mod_geo.distance(latitudes[i + 1], longitudes[i + 1], None, latitudes[i], longitudes[i], None)\n                dist = mod_geo.distance(latitudes[i - 1], longitudes[i - 1], None, latitudes[i + 1], longitudes[i + 1], None)\n\n                if d1 + d2 > dist * 1.5 and remove_extremes:\n                    dist = mod_geo.distance(old_latitude, old_longitude, None, new_latitude, new_longitude, None)\n                    if dist < remove_2d_extremes_threshold:\n                        new_point = self.points[i]\n                    else:\n                        point_removed = True\n                else:\n                    new_point = self.points[i]\n\n            if new_point and not point_removed:\n                new_track_points.append(new_point)\n\n        new_track_points.append(self.points[- 1])\n\n        self.points = new_track_points\n\n    def has_times(self) -> bool:\n        \"\"\"\n        Returns if points in this segment contains timestamps.\n\n        The first point, the last point, and 75% of the points must have times\n        for this method to return true.\n        \"\"\"\n        if not self.points:\n            return True\n\n        found = 0\n        for track_point in self.points:\n            if track_point.time:\n                found += 1\n\n        return len(self.points) > 2 and found / len(self.points) > .6\n\n    def has_elevations(self) -> bool:\n        \"\"\"\n        Returns if points in this segment contains elevation.\n\n        The first point, the last point, and at least 75% of the points must\n        have elevation for this method to return true.\n        \"\"\"\n        if not self.points:\n            return True\n\n        found = 0\n        for track_point in self.points:\n            if track_point.elevation:\n                found += 1\n\n        return len(self.points) > 2 and found / len(self.points) > .6\n\n\n    def __repr__(self) -> str:\n        return f'GPXTrackSegment(points=[{\"...\" if self.points else \"\"}])'\n\n    def clone(self) -> \"GPXTrackSegment\":\n        return mod_copy.deepcopy(self)\n```",
  "rewrite": "class GPXTrackSegment:\n    gpx_10_fields = [\n            mod_gpxfield.GPXComplexField('points', tag='trkpt', classs=GPXTrackPoint, is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXComplexField('points', tag='trkpt', classs=GPXTrackPoint, is_list=True),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n    ]\n\n    __slots__ = ('points', 'extensions', )\n\n    def __init__(self, points: Optional[List[GPXTrackPoint]]=None) -> None:\n        self.points: List[GPXTrackPoint] = points if points else []\n        self.extensions: List[Any] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        \"\"\"\n        Simplify using the Ramer-Douglas-Peucker algorithm: http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n        \"\"\"\n        self.points = mod_geo.simplify_polyline(self.points, max_distance) # type: ignore\n\n    def reduce_points(self, min_distance: float) -> None:\n        \"\"\"\n        Reduces the number of points in the track segment. Segment points will\n        be updated in place.\n\n        Parameters\n        ----------\n        min_distance : float\n            The minimum separation in meters between points\n        \"\"\"\n        reduced_points: List[GPXTrackPoint] = []\n        for point in self.points:\n            if reduced_points:\n                distance = reduced_points[-1].distance_3d(point)\n                if min_distance is not None and distance is not None and distance > min_distance:\n                    reduced_points.append(point)\n            else:\n                reduced_points.append(point)\n\n        self.points = reduced_points\n\n    def adjust_time(self, delta: mod_datetime.timedelta) -> None:\n        \"\"\"\n        Adjusts the time of all points in the segment by the specified delta\n\n        Parameters\n        ----------\n        delta : datetime.timedelta\n            Positive time delta will adjust point times into the future\n            Negative time delta will adjust point times into the past\n        \"\"\"\n        for track_point in self.points:\n            track_point.adjust_time(delta)\n\n    def remove_time(self) -> None:\n        \"\"\" Removes time data for all points in the segment. \"\"\"\n        for track_point in self.points:\n            track_point.remove_time()\n\n    def remove_elevation(self) -> None:\n        \"\"\" Removes elevation data for all points in the segment. \"\"\"\n        for track_point in self.points:\n            track_point.remove_elevation()\n\n    def length_2d(self) -> Optional[float]:\n        \"\"\"\n        Computes 2-dimensional length (meters) of segment (only latitude and\n        longitude, no elevation).\n\n        Returns\n        ----------\n        length : float\n            Length returned in meters\n        \"\"\"\n        return mod_geo.length_2d(self.points) # type: ignore\n\n    def length_3d(self) -> float:\n        \"\"\"\n        Computes 3-dimensional length of segment (latitude, longitude, and\n        elevation).\n\n        Returns\n        ----------\n        length : float\n            Length returned in meters\n        \"\"\"\n        return mod_geo.length_3d(self.points) # type: ignore\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        \"\"\"\n        Moves each point in the segment.\n\n        Parameters\n        ----------\n        location_delta: LocationDelta object\n            Delta (distance/angle or lat/lon offset to apply each point in the\n            segment\n        \"\"\"\n        for track_point in self.points:\n            track_point.move(location_delta)\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        \"\"\"\n        Generator for iterating over segment points\n\n        Parameters\n        ----------\n        only_points: boolean\n            Only yield points (no index yielded)\n\n        Yields\n        ------\n        point: GPXTrackPoint\n            A point in the sement\n        point_no: int\n            Not included in yield if only_points is true\n        \"\"\"\n        for point_no, point in enumerate(self.points if self.points else []):\n            if only_points:\n                yield point\n            else:\n                yield point, point_no\n\n    def get_points_no(self) -> int:\n        \"\"\"\n        Gets the number of points in segment.\n\n        Returns\n        ----------\n        num_points : integer\n            Number of points in segment\n        \"\"\"\n        if not self.points:\n            return 0\n        return len(self.points)\n\n    def split(self, point_no: int) -> Tuple[\"GPXTrackSegment\", \"GPXTrackSegment\"]:\n        \"\"\"\n        Splits the segment into two parts.\n\n        Parameters\n        ----------\n        point_no : integer\n            The index of the track point in the segment to split\n        \"\"\"\n        part_1 = self.points[:point_no + 1]\n        part_2 = self.points[point_no:]\n        return GPXTrackSegment(part_1), GPXTrackSegment(part_2)\n\n    def join(self, track_segment: \"GPXTrackSegment\") -> None:\n        \"\"\" Joins with another segment \"\"\"\n        self.points += track_segment.points\n\n    def remove_point(self, point_no: int) -> None:\n        \"\"\" Removes a point specified by index from the segment \"\"\"\n        if point_no < 0 or point_no >= len(self.points):\n            return\n\n        part_1 = self.points[:point_no]\n        part_2 = self.points[point_no + 1:]\n\n        self.points = part_1 + part_2\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool = True) -> Optional[MovingData]:\n        \"\"\"\n        Return a tuple of (moving_time, stopped_time, moving_distance,\n        stopped_distance, max_speed) that may be used for detecting the time\n        stopped, and max speed. Not that those values are not absolutely true,\n        because the \"stopped\" or \"moving\" information aren't saved in the segment.\n\n        Because of errors in the GPS recording, it may be good to calculate\n        them on a reduced and smoothed version of the track.\n\n        Parameters\n        ----------\n        stopped_speed_threshold : float\n            speeds (km/h) below this threshold are treated as if having no\n            movement. Default is 1 km/h.\n\n        Returns\n        ----------\n        moving_data : MovingData : named tuple\n            moving_time : float\n                time (seconds) of segment in which movement was occurring\n            stopped_time : float\n                time (seconds) of segment in which no movement was occurring\n            stopped_distance : float\n                distance (meters) travelled during stopped times\n            moving_distance : float\n                distance (meters) travelled during moving times\n            max_speed : float\n                Maximum speed (m/s) during the segment.\n        \"\"\"\n        if not stopped_speed_threshold:\n            stopped_speed_threshold = DEFAULT_STOPPED_SPEED_THRESHOLD\n\n        if raw:\n            speed_extreemes_percentiles=0\n            ignore_nonstandard_distances=False\n\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        speeds_and_distances = []\n\n        for previous, point in zip(self.points, self.points[1:]):\n\n            if point.time and previous.time:\n                timedelta = point.time - previous.time\n\n                if point.elevation and previous.elevation:\n                    distance = point.distance_3d(previous)\n                else:\n                    distance = point.distance_2d(previous)\n\n                seconds = mod_utils.total_seconds(timedelta)\n                speed_kmh: float = 0\n                if seconds > 0 and distance is not None:\n                    speed_kmh = (distance / 1000) / (seconds / 60 ** 2)\n                    if distance:\n                        if speed_kmh <= stopped_speed_threshold:\n                            stopped_time += seconds\n                            stopped_distance += distance\n                        else:\n                            moving_time += seconds\n                            moving_distance += distance\n                        if moving_time:\n                            speeds_and_distances.append((distance / seconds, distance, ))\n\n        max_speed = None\n        if speeds_and_distances:\n            max_speed = mod_geo.calculate_max_speed(speeds_and_distances, speed_extreemes_percentiles, ignore_nonstandard_distances)\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed or 0.0)\n\n    def get_time_bounds(self) -> TimeBounds:\n        \"\"\"\n        Gets the time bound (start and end) of the segment.\n\n        returns\n        ----------\n        time_bounds : TimeBounds named tuple\n            start_time : datetime\n                Start time of the first segment in track\n            end time : datetime\n                End time of the last segment in track\n        \"\"\"\n        start_time = None\n        end_time = None\n\n        for point in self.points:\n            if point.time:\n                if not start_time:\n                    start_time = point.time\n                if point.time and (not end_time or point.time > end_time):\n                    end_time = point.time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        \"\"\"\n        Gets the latitude and longitude bounds of the segment.\n\n        Returns\n        ----------\n        bounds : Bounds named tuple\n            min_latitude : float\n                Minimum latitude of segment in decimal degrees [-90, 90]\n            max_latitude : float\n                Maximum latitude of segment in decimal degrees [-90, 90]\n            min_longitude : float\n                Minimum longitude of segment in decimal degrees [-180, 180]\n            max_longitude : float\n                Maximum longitude of segment in decimal degrees [-180, 180]\n        \"\"\"\n        min_lat = None\n        max_lat = None\n        min_lon = None\n        max_lon = None\n\n        for point in self.points:\n            if min_lat is None or point.latitude < min_lat:\n                min_lat = point.latitude\n            if max_lat is None or point.latitude > max_lat:\n                max_lat = point.latitude\n            if min_lon is None or point.longitude > min_lon:\n                min_lon = point.longitude\n            if max_lon is None or point.longitude < max_lon:\n                max_lon = point.longitude\n\n        if min_lat and max_lat and min_lon and max_lon:\n            return GPXBounds(min_lat, max_lat, min_lon, max_lon)\n        return None\n\n    def get_speed(self, point_no: int) -> Optional[float]:\n        \"\"\"\n        Computes the speed at the specified point index.\n\n        Parameters\n        ----------\n        point_no : integer\n            index of the point used to compute speed\n\n        Returns\n        ----------\n        speed : float\n            Speed returned in m/s\n        \"\"\"\n        point = self.points[point_no]\n\n        previous_point = None\n        next_point = None\n\n        if 0 < point_no < len(self.points):\n            previous_point = self.points[point_no - 1]\n        if 0 <= point_no < len(self.points) - 1:\n            next_point = self.points[point_no + 1]\n\n        speed_1 = point.speed_between(previous_point) if previous_point else None\n        speed_2 = point.speed_between(next_point) if next_point else None\n\n        if speed_1:\n            speed_1 = abs(speed_1)\n        if speed_2:\n            speed_2 = abs(speed_2)\n\n        if speed_1 and speed_2:\n            return max(speed_1, speed_2)\n\n        if speed_1:\n            return speed_1\n\n        return speed_2\n\n    def add_elevation(self, delta: float) -> None:\n        \"\"\"\n        Adjusts elevation data for segment.\n\n        Parameters\n        ----------\n        delta : float\n            Elevation delta in meters to apply to track\n        \"\"\"\n        log.debug('delta = %s', delta)\n\n        if not delta:\n            return\n\n        for track_point in self.points:\n            if track_point.elevation is not None:\n                track_point.elevation += delta\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        \"\"\"\n        Calculate missing data.\n\n        Parameters\n        ----------\n        get_data_function : object\n            Returns the data from point\n        add_missing_function : void\n            Function with the following arguments: array with points with missing data, the point before them (with data),\n            the point after them (with data), and distance ratios between points in the interval (the sum of distances ratios\n            will be 1)\n        \"\"\"\n        if not get_data_function:\n            raise GPXException(f'Invalid get_data_function: {get_data_function}')\n        if not add_missing_function:\n            raise GPXException(f'Invalid add_missing_function: {add_missing_function}')\n\n        interval: List[GPXTrackPoint] = []\n        start_point = None\n\n        previous_point = None\n        for track_point in self.points:\n            data = get_data_function(track_point)\n            if data is None and previous_point:\n                if not start_point:\n                    start_point = previous_point\n                interval.append(track_point)\n            else:\n                if interval and start_point:\n                    distances_ratios = self._get_interval_distances_ratios(interval, start_point, track_point)\n                    add_missing_function(interval, start_point, track_point, distances_ratios)\n                    start_point = None\n                    interval = []\n            previous_point = track_point\n\n    def _get_interval_distances_ratios(self, interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint) -> List[float]:\n        assert start, start\n        assert end, end\n        assert interval, interval\n        assert len(interval) > 0, interval\n\n        distances = []\n        distance_from_start: float = 0\n        previous_point = start\n        for point in interval:\n            dist = point.distance_3d(previous_point)\n            if dist is not None:\n                distance_from_start += dist\n                distances.append(distance_from_start)\n                previous_point = point\n\n        dist = interval[-1].distance_3d(end)\n        from_start_to_end = None\n        if dist:\n            from_start_to_end = distances[-1] + dist\n\n        assert len(interval) == len(distances)\n\n        return [(distance / from_start_to_end) if from_start_to_end else 0\n                for distance in distances]\n\n    def get_duration(self) -> Optional[float]:\n        \"\"\"\n        Calculates duration or track segment\n\n        Returns\n        -------\n        duration: float\n            Duration in seconds\n        \"\"\"\n        if not self.points or len(self.points) < 2:\n            return 0.0\n\n        first = self.points[0]\n        if not first.time:\n            first = self.points[1]\n\n        last = self.points[-1]\n        if not last.time:\n            last = self.points[-2]\n\n        if not last.time or not first.time:\n            log.debug('Can\\'t find time')\n            return None\n\n        if last.time < first.time:\n            log.debug('Not enough time data')\n            return None\n\n        return mod_utils.total_seconds(last.time - first.time)\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        \"\"\"\n        Calculates the uphill and downhill elevation climbs for the track\n        segment. If elevation for some points is not found those are simply\n        ignored.\n\n        Returns\n        -------\n        uphill_downhill: UphillDownhill named tuple\n            uphill: float\n                Uphill elevation climbs in meters\n            downhill: float\n                Downhill elevation descent in meters\n        \"\"\"\n        if not self.points:\n            return UphillDownhill(0, 0)\n\n        elevations = [point.elevation for point in self.points]\n        uphill, downhill = mod_geo.calculate_uphill_downhill(elevations)\n\n        return UphillDownhill(downhill, uphill)\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        \"\"\"\n        Calculate elevation extremes of track segment\n\n        Returns\n        -------\n        min_max_elevation: MinimumMaximum named tuple\n            minimum: float\n                Minimum elevation in meters\n            maximum: float\n                Maximum elevation in meters\n        \"\"\"\n        if not self.points:\n            return MinimumMaximum(None, None)\n\n        elevations = [x.elevation for x in self.points if x.elevation is not None]\n        if not elevations:\n            return MinimumMaximum(None, None)\n        return MinimumMaximum(max(elevations), min(elevations))\n\n    def get_location_at(self, time: mod_datetime.datetime) -> Optional[GPXTrackPoint]:\n        \"\"\"\n        Gets approx. location at given time. Note that, at the moment this\n        method returns an instance of GPXTrackPoint in the future -- this may\n        be a mod_geo.Location instance with approximated latitude, longitude\n        and elevation!\n        \"\"\"\n        if not self.points:\n            return None\n\n        if not time:\n            return None\n\n        first_time = self.points[0].time\n        last_time = self.points[-1].time\n\n        if not first_time and not last_time:\n            log.debug('No times for track segment')\n            return None\n\n        if first_time and time and last_time and not first_time <= time <= last_time:\n            log.debug(f'Not in track (search for:{time}, start:{first_time}, end:{last_time})')\n            return None\n\n        for point in self.points:\n            if point.time and time < point.time:\n                return point\n        \n        return None\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        \"\"\" Return the (location, track_point_no) on this track segment \"\"\"\n        return min((NearestLocationData(pt, -1, -1, pt_no) for (pt, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        \"\"\" \"Smooths\" the elevation graph. Can be called multiple times. \"\"\"\n        if len(self.points) <= 3:\n            return\n\n        elevations: List[float] = []\n        latitudes: List[float] = []\n        longitudes: List[float] = []\n\n        for point in self.points:\n            elevations.append(point.elevation or 0)\n            latitudes.append(point.latitude or 0)\n            longitudes.append(point.longitude or 0)\n\n        avg_distance: float = 0\n        avg_elevation_delta: float = 1\n        if remove_extremes:\n            distances: List[float] = []\n            elevations_delta = []\n            for prev, cur in zip(self.points, self.points[1:]):\n                dist = prev.distance_2d(cur)\n                if dist:\n                    distances.append(dist)\n                if cur.elevation is not None and prev.elevation is not None:\n                    elevations_delta.append(abs(cur.elevation - prev.elevation))\n            if distances:\n                avg_distance = 1.0 * sum(distances) / len(distances)\n            if elevations_delta:\n                avg_elevation_delta = 1.0 * sum(elevations_delta) / len(elevations_delta)\n\n        remove_2d_extremes_threshold = 1.75 * avg_distance\n        remove_elevation_extremes_threshold = avg_elevation_delta * 5\n\n        new_track_points = [self.points[0]]\n\n        for i in range(len(self.points))[1:-1]:\n            new_point = None\n            point_removed = False\n            if vertical and elevations[i - 1] and elevations[i] and elevations[i + 1]:\n                old_elevation = self.points[i].elevation\n                new_elevation = 0.4 * elevations[i - 1] + \\\n                    0.2 * elevations[i] + \\\n                    0.4 * elevations[i + 1]\n\n                if not remove_extremes:\n                    self.points[i].elevation = new_elevation\n\n                if remove_extremes:\n                    d1 = abs((old_elevation or 0) - elevations[i - 1])\n                    d2 = abs((old_elevation or 0) - elevations[i + 1])\n\n                    if min(d1, d2) < remove_elevation_extremes_threshold and abs((old_elevation or 0) - (new_elevation or 0)) < remove_2d_extremes_threshold:\n                        new_point = self.points[i]\n                    else:\n                        point_removed = True\n                else:\n                    new_point = self.points[i]\n            else:\n                new_point = self.points[i]\n\n            if horizontal:\n                old_latitude = self.points[i].latitude\n                new_latitude = 0.4 * latitudes[i - 1] + \\\n                    0.2 * latitudes[i] + \\\n                    0.4 * latitudes[i + 1]\n                old_longitude = self.points[i].longitude\n                new_longitude = 0.4 * longitudes[i - 1] + \\\n                    0.2 * longitudes[i] + \\\n                    0.4 * longitudes[i + 1]\n\n                if not remove_extremes:\n                    self.points[i].latitude = new_latitude\n                    self.points[i].longitude = new_longitude\n\n                d1 = mod_geo.distance(latitudes[i - 1], longitudes[i - 1], None, latitudes[i], longitudes[i], None)\n                d2 = mod_geo.distance(latitudes[i + 1], longitudes[i + 1], None, latitudes[i], longitudes[i], None)\n                dist = mod_geo.distance(latitudes[i - 1], longitudes[i - 1], None, latitudes[i + 1], longitudes[i + 1], None)\n\n                if d1 + d2 > dist * 1.5 and remove_extremes:\n                    dist = mod_geo.distance(old_latitude, old_longitude, None, new_latitude, new_longitude, None)\n                    if dist < remove_2d_extremes_threshold:\n                        new_point = self.points[i]\n                    else:\n                        point_removed = True\n                else:\n                    new_point = self.points[i]\n\n            if new_point and not point_removed:\n                new_track_points.append(new_point)\n\n        new_track_points.append(self.points[- 1])\n\n        self.points = new_track_points\n\n    def has_times(self) -> bool:\n        \"\"\"\n        Returns if points in this segment contains timestamps.\n\n        The first point, the last point, and 75% of the points must have times\n        for this method to return true.\n        \"\"\"\n        if not self.points:\n            return True\n\n        found = 0\n        for track_point in self.points:\n            if track_point.time:\n                found += 1\n\n        return len(self.points) > 2 and found / len(self.points) > .6\n\n    def has_elevations(self) -> bool:\n        \"\"\"\n        Returns if points in this segment contains elevation.\n\n        The first point, the last point, and at least 75% of the points must\n        have elevation for this method to return true.\n        \"\"\"\n        if not self.points:\n            return True\n\n        found = 0\n        for track_point in self.points:\n            if track_point.elevation:\n                found += 1\n\n        return len(self.points) > 2 and found / len(self.points) > .6\n\n\n    def __repr__(self) -> str:\n        return f'GPXTrackSegment(points=[{\"...\" if self.points else \"\"}])'\n\n    def clone(self) -> \"GPXTrackSegment\":\n        return mod_copy.deepcopy(self)",
  "strategy": "llm"
}