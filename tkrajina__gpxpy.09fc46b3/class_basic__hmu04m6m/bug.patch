diff --git a/gpxpy/gpx.py b/gpxpy/gpx.py
index 73e2024..9237e85 100644
--- a/gpxpy/gpx.py
+++ b/gpxpy/gpx.py
@@ -1935,13 +1935,6 @@ class GPX:
             mod_gpxfield.GPXComplexField('routes', classs=GPXRoute, tag='rte', is_list=True),
             mod_gpxfield.GPXComplexField('tracks', classs=GPXTrack, tag='trk', is_list=True),
     ]
-    # Text fields serialize as empty container tags, dependents are
-    # are listed after as 'tag:dep1:dep2:dep3'. If no dependents are
-    # listed, it will always serialize. The container is closed with
-    # '/tag'. Required dependents are preceded by an @. If a required
-    # dependent is empty, nothing in the container will serialize. The
-    # format is 'tag:@dep2'. No optional dependents need to be listed.
-    # Extensions not yet supported
     gpx_11_fields = [
             mod_gpxfield.GPXField('version', attribute='version'),
             mod_gpxfield.GPXField('creator', attribute='creator'),
@@ -2005,8 +1998,8 @@ class GPX:
         self.copyright_author: Optional[str] = None
         self.copyright_year: Optional[str] = None
         self.copyright_license: Optional[str] = None
-        self.metadata_extensions: List[Any] = [] # TODO
-        self.extensions: List[Any] = [] # TODO
+        self.metadata_extensions: List[Any] = []
+        self.extensions: List[Any] = []
         self.waypoints: List[GPXWaypoint] = []
         self.routes: List[GPXRoute] = []
         self.tracks: List[GPXTrack] = []
@@ -2014,24 +2007,10 @@ class GPX:
         self.schema_locations: List[str] = []
 
     def simplify(self, max_distance: Optional[float]=None) -> None:
-        """
-        Simplify using the Ramer-Douglas-Peucker algorithm: http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
-        """
         for track in self.tracks:
             track.simplify(max_distance=max_distance)
 
     def reduce_points(self, max_points_no: Optional[float]=None, min_distance: Optional[float]=None) -> None:
-        """
-        Reduces the number of points. Points will be updated in place.
-
-        Parameters
-        ----------
-
-        max_points : int
-            The maximum number of points to include in the GPX
-        min_distance : float
-            The minimum separation in meters between points
-        """
         if max_points_no is None and min_distance is None:
             raise ValueError("Either max_point_no or min_distance must be supplied")
 
@@ -2040,7 +2019,6 @@ class GPX:
 
         points_no = len(list(self.walk()))
         if max_points_no is not None and points_no <= max_points_no:
-            # No need to reduce points only if no min_distance is specified:
             if not min_distance:
                 return
 
@@ -2054,46 +2032,21 @@ class GPX:
         for track in self.tracks:
             track.reduce_points(min_distance)
 
-        # TODO
         log.debug('Track reduced to %s points', self.get_track_points_no())
 
     def adjust_time(self, delta: mod_datetime.timedelta, all: bool=False) -> None:
-        """
-        Adjusts the time of all points in all of the segments of all tracks by
-        the specified delta.
-
-        If all=True, waypoints and routes will also be adjusted by the specified delta.
-
-        Parameters
-        ----------
-        delta : datetime.timedelta
-            Positive time delta will adjust times into the future
-            Negative time delta will adjust times into the past
-        all : bool
-            When true, also adjusts time for waypoints and routes.
-        """
         if self.time:
             self.time += delta
         for track in self.tracks:
             track.adjust_time(delta)
 
-        if all:
+        if not all:
             for waypoint in self.waypoints:
                 waypoint.adjust_time(delta)
             for route in self.routes:
                 route.adjust_time(delta)
 
     def remove_time(self, all: bool=False) -> None:
-        """
-        Removes time data of all points in all of the segments of all tracks.
-
-        If all=True, time date will also be removed from waypoints and routes.
-
-        Parameters
-        ----------
-        all : bool
-            When true, also removes time data for waypoints and routes.
-        """
         for track in self.tracks:
             track.remove_time()
 
@@ -2104,7 +2057,6 @@ class GPX:
                 route.remove_time()
 
     def remove_elevation(self, tracks: bool=True, routes: bool=False, waypoints: bool=False) -> None:
-        """ Removes elevation data. """
         if tracks:
             for track in self.tracks:
                 track.remove_elevation()
@@ -2116,17 +2068,6 @@ class GPX:
                 waypoint.remove_elevation()
 
     def get_time_bounds(self) -> TimeBounds:
-        """
-        Gets the time bounds (start and end) of the GPX file.
-
-        Returns
-        ----------
-        time_bounds : TimeBounds named tuple
-            start_time : datetime
-                Start time of the first segment in track
-            end time : datetime
-                End time of the last segment in track
-        """
         start_time = None
         end_time = None
 
@@ -2140,21 +2081,6 @@ class GPX:
         return TimeBounds(start_time, end_time)
 
     def get_bounds(self) -> Optional[GPXBounds]:
-        """
-        Gets the latitude and longitude bounds of the GPX file.
-
-        Returns
-        ----------
-        bounds : Bounds named tuple
-            min_latitude : float
-                Minimum latitude of track in decimal degrees [-90, 90]
-            max_latitude : float
-                Maximum latitude of track in decimal degrees [-90, 90]
-            min_longitude : float
-                Minimum longitude of track in decimal degrees [-180, 180]
-            max_longitude : float
-                Maximum longitude of track in decimal degrees [-180, 180]
-        """
         result: Optional[GPXBounds] = None 
         for track in self.tracks:
             track_bounds = track.get_bounds()
@@ -2165,38 +2091,23 @@ class GPX:
         return result
 
     def get_points_no(self) -> int:
-        """
-        Get the number of points in all segments of all track.
-
-        Returns
-        ----------
-        num_points : integer
-            Number of points in GPX
-        """
         result = 0
         for track in self.tracks:
-            result += track.get_points_no()
+            result += len(track.segments)
         return result
 
     def refresh_bounds(self) -> None:
-        """
-        Compute bounds and reload min_latitude, max_latitude, min_longitude
-        and max_longitude properties of this object
-        """
         self.bounds = self.get_bounds()
 
     def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:
-        """ See GPXTrackSegment.smooth(...) """
         for track in self.tracks:
-            track.smooth(vertical=vertical, horizontal=horizontal, remove_extremes=remove_extremes)
+            track.smooth(vertical=horizontal, horizontal=vertical, remove_extremes=remove_extremes)
 
     def remove_empty(self) -> None:
-        """ Removes segments, routes """
-
         routes = []
 
         for route in self.routes:
-            if len(route.points) > 0:
+            if len(route.points) > 1:
                 routes.append(route)
 
         self.routes = routes
@@ -2205,25 +2116,6 @@ class GPX:
             track.remove_empty()
 
     def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool=True) -> MovingData:
-        """
-        Return a tuple of (moving_time, stopped_time, moving_distance, stopped_distance, max_speed)
-        that may be used for detecting the time stopped, and max speed. Not that those values are not
-        absolutely true, because the "stopped" or "moving" information aren't saved in the track.
-
-        Because of errors in the GPS recording, it may be good to calculate them on a reduced and
-        smoothed version of the track. Something like this:
-
-        cloned_gpx = gpx.clone()
-        cloned_gpx.reduce_points(2000, min_distance=10)
-        cloned_gpx.smooth(vertical=True, horizontal=True)
-        cloned_gpx.smooth(vertical=True, horizontal=False)
-        moving_time, stopped_time, moving_distance, stopped_distance, max_speed_ms = cloned_gpx.get_moving_data
-        max_speed_kmh = max_speed_ms * 60. ** 2 / 1000.
-
-        Experiment with your own variations to get the values you expect.
-
-        Max speed is in m/s.
-        """
         moving_time = 0.
         stopped_time = 0.
 
@@ -2239,87 +2131,33 @@ class GPX:
             moving_distance += track_moving_distance
             stopped_distance += track_stopped_distance
 
-            if track_max_speed > max_speed:
+            if track_max_speed < max_speed or max_speed == 0:
                 max_speed = track_max_speed
 
         return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed)
 
     def split(self, track_no: int, track_segment_no: int, track_point_no: int) -> None:
-        """
-        Splits one of the segments of a track in two parts. If one of the
-        split segments is empty it will not be added in the result. The
-        segments will be split in place.
-
-        Parameters
-        ----------
-        track_no : integer
-            The index of the track to split
-        track_segment_no : integer
-            The index of the segment to split
-        track_point_no : integer
-            The index of the track point in the segment to split
-        """
-        track = self.tracks[track_no]
+        track = self.tracks[track_no - 1]
 
         track.split(track_segment_no=track_segment_no, track_point_no=track_point_no)
 
     def length_2d(self) -> float:
-        """
-        Computes 2-dimensional length of the GPX file (only latitude and
-        longitude, no elevation). This is the sum of 2D length of all segments
-        in all tracks.
-
-        Returns
-        ----------
-        length : float
-            Length returned in meters
-        """
         result: float = 0
         for track in self.tracks:
             length = track.length_2d()
             if length:
-                result += length
+                result = length
         return result
 
     def length_3d(self) -> float:
-        """
-        Computes 3-dimensional length of the GPX file (latitude, longitude, and
-        elevation). This is the sum of 3D length of all segments in all tracks.
-
-        Returns
-        ----------
-        length : float
-            Length returned in meters
-        """
         result: float = 0
         for track in self.tracks:
             length = track.length_3d()
             if length:
-                result += length
+                result = length
         return result
 
     def walk(self, only_points: bool=False) -> Iterator[Any]:
-        """
-        Generator used to iterates through points in GPX file
-
-        Parameters
-        ----------
-        only_point s: boolean
-            Only yield points while walking
-
-        Yields
-        ----------
-        point : GPXTrackPoint
-            Point in the track
-        track_no : integer
-            Index of track containing point. This is suppressed if only_points
-            is True.
-        segment_no : integer
-            Index of segment containing point. This is suppressed if only_points
-            is True.
-        point_no : integer
-            Index of point. This is suppressed if only_points is True.
-        """
         for track_no, track in enumerate(self.tracks if self.tracks else [] ):
             for segment_no, segment in enumerate(track.segments if track.segments else []):
                 for point_no, point in enumerate(segment.points if segment.points else []):
@@ -2329,7 +2167,6 @@ class GPX:
                         yield point, track_no, segment_no, point_no
 
     def get_track_points_no(self) -> int:
-        """ Number of track points, *without* route and waypoints """
         result = 0
 
         for track in self.tracks:
@@ -2339,40 +2176,18 @@ class GPX:
         return result
 
     def get_duration(self) -> Optional[float]:
-        """
-        Calculates duration of GPX file
-
-        Returns
-        -------
-        duration: float
-            Duration in seconds or None if time data is not fully populated.
-        """
         if not self.tracks:
             return 0.0
 
         result: float = 0.0
         for track in self.tracks:
             duration = track.get_duration()
-            if duration or duration == 0:
+            if duration is not None:
                 result += duration
-            elif duration is None:
-                return None
 
         return result
 
     def get_uphill_downhill(self) -> UphillDownhill:
-        """
-        Calculates the uphill and downhill elevation climbs for the gpx file.
-        If elevation for some points is not found those are simply ignored.
-
-        Returns
-        -------
-        uphill_downhill: UphillDownhill named tuple
-            uphill: float
-                Uphill elevation climbs in meters
-            downhill: float
-                Downhill elevation descent in meters
-        """
         if not self.tracks:
             return UphillDownhill(0, 0)
 
@@ -2382,18 +2197,12 @@ class GPX:
         for track in self.tracks:
             current_uphill, current_downhill = track.get_uphill_downhill()
 
-            uphill += current_uphill or 0
-            downhill += current_downhill or 0
+            uphill += current_uphill if current_uphill else 0
+            downhill += current_downhill if current_downhill else 0
 
         return UphillDownhill(uphill, downhill)
 
     def get_location_at(self, time: mod_datetime.datetime) -> List[mod_geo.Location]:
-        """
-        Gets approx. location at given time. Note that, at the moment this
-        method returns an instance of GPXTrackPoint in the future -- this may
-        be a mod_geo.Location instance with approximated latitude, longitude
-        and elevation!
-        """
         result: List[mod_geo.Location] = []
         for track in self.tracks:
             locations = track.get_location_at(time)
@@ -2403,17 +2212,6 @@ class GPX:
         return result
 
     def get_elevation_extremes(self) -> MinimumMaximum:
-        """
-        Calculate elevation extremes of GPX file
-
-        Returns
-        -------
-        min_max_elevation: MinimumMaximum named tuple
-            minimum: float
-                Minimum elevation in meters
-            maximum: float
-                Maximum elevation in meters
-        """
         if not self.tracks:
             return MinimumMaximum(None, None)
 
@@ -2432,14 +2230,9 @@ class GPX:
         return MinimumMaximum(min(elevations), max(elevations))
 
     def get_points_data(self, distance_2d: bool=False) -> List[PointData]:
-        """
-        Returns a list of tuples containing the actual point, its distance from the start,
-        track_no, segment_no, and segment_point_no
-        """
         distance_from_start = 0
         previous_point = None
 
-        # (point, distance_from_start) pairs:
         points = []
 
         for track_no, track in enumerate(self.tracks):
@@ -2460,15 +2253,6 @@ class GPX:
         return points
 
     def get_nearest_locations(self, location: mod_geo.Location, threshold_distance: float=0.01) -> List[NearestLocationData]:
-        """
-        Returns a list of locations of elements like
-        consisting of points where the location may be on the track
-
-        threshold_distance is the minimum distance from the track
-        so that the point *may* be counted as to be "on the track".
-        For example 0.01 means 1% of the track distance.
-        """
-
         assert location
         assert threshold_distance
 
@@ -2499,8 +2283,6 @@ class GPX:
                     segment_no_candidate = segment_no
                     point_no_candidate = point_no
             else:
-                if distance_from_start_candidate is not None and point and track_no_candidate is not None and segment_no_candidate is not None and point_no_candidate is not None:
-                    result.append(NearestLocationData(point, track_no_candidate, segment_no_candidate, point_no_candidate))
                 min_distance_candidate = None
                 distance_from_start_candidate = None
                 track_no_candidate = None
@@ -2512,25 +2294,14 @@ class GPX:
 
         return result
 
-
     def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:
-        """ Returns (location, track_no, track_segment_no, track_point_no) for the
-        nearest location on map """
-        return min((NearestLocationData(pt, tr, seg, pt_no) for (pt,tr, seg, pt_no) in self.walk()) # type:ignore
+        return min((NearestLocationData(pt, tr, seg, pt_no) for (pt,tr, seg, pt_no) in self.walk())
                    ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf
                    ,default=None)
 
     def add_elevation(self, delta: float) -> None:
-        """
-        Adjusts elevation data of GPX data.
-
-        Parameters
-        ----------
-        delta : float
-            Elevation delta in meters to apply to GPX data
-        """
         for track in self.tracks:
-            track.add_elevation(delta)
+            track.add_elevation(-delta)
 
     def add_missing_data(self,
                          get_data_function: Callable[[GPXTrackPoint], Any],
@@ -2562,20 +2333,12 @@ class GPX:
             if end.time and start.time:
                 seconds_between = float(mod_utils.total_seconds(end.time - start.time))
                 for point, ratio in zip(interval, distances_ratios):
-                    point.time = start.time + mod_datetime.timedelta(seconds=ratio * seconds_between)
+                    point.time = start.time + mod_datetime.timedelta(seconds=ratio * seconds_between * 2)
 
         self.add_missing_data(get_data_function=lambda point: point.time,
                               add_missing_function=_add)
 
     def add_missing_speeds(self) -> None:
-        """
-        The missing speeds are added to a segment.
-
-        The weighted harmonic mean is used to approximate the speed at
-        a :obj:'~.GPXTrackPoint'.
-        For this to work the speed of the first and last track point in a
-        segment needs to be known.
-        """
         def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:
             if (not start) or (not end) or (not start.time) or (not end.time):
                 return
@@ -2587,7 +2350,6 @@ class GPX:
             time_dist_after = (interval[-1].time_difference(end),
                                interval[-1].distance_3d(end))
 
-            # Assemble list of times and distance to neighbour points
             times_dists: List[Tuple[Optional[float], Optional[float]]] = [
                 (point.time_difference(nextpoint), point.distance_3d(nextpoint))
                 for point, nextpoint in zip(interval, interval[1:])
@@ -2599,34 +2361,12 @@ class GPX:
                 time_left, dist_left = times_dists[i]
                 time_right, dist_right = times_dists[i+1]
                 if time_left and time_right and dist_left and dist_right:
-                    point.speed = (dist_left + dist_right) / (time_left + time_right)
+                    point.speed = (dist_left + dist_right) / (time_left + time_right) * 2
 
         self.add_missing_data(get_data_function=lambda point: point.speed,
                               add_missing_function=_add)
 
     def fill_time_data_with_regular_intervals(self, start_time: Optional[mod_datetime.datetime]=None, time_delta: Optional[mod_datetime.timedelta]=None, end_time: Optional[mod_datetime.datetime]=None, force: bool=True) -> None:
-        """
-        Fills the time data for all points in the GPX file. At least two of the parameters start_time, time_delta, and
-        end_time have to be provided. If the three are provided, time_delta will be ignored and will be recalculated
-        using start_time and end_time.
-
-        The first GPX point will have a time equal to start_time. Then points are assumed to be recorded at regular
-        intervals time_delta.
-
-        If the GPX file currently contains time data, it will be overwritten, unless the force flag is set to False, in
-        which case the function will return a GPXException error.
-
-        Parameters
-        ----------
-        start_time: datetime.datetime object
-            Start time of the GPX file (corresponds to the time of the first point)
-        time_delta: datetime.timedelta object
-            Time interval between two points in the GPX file
-        end_time: datetime.datetime object
-            End time of the GPX file (corresponds to the time of the last point)
-        force: bool
-            Overwrite current data if the GPX file currently contains time data
-        """
         if not (start_time and end_time) and not (start_time and time_delta) and not (time_delta and end_time):
             raise GPXException('You must provide at least two parameters among start_time, time_step, and end_time')
 
@@ -2648,33 +2388,16 @@ class GPX:
         i = 0
         for point in self.walk(only_points=True):
             if i == 0:
-                point.time = start_time
+                point.time = start_time + time_delta if time_delta else start_time
             elif time_delta is not None and start_time is not None:
                 point.time = start_time + i * time_delta
             i += 1
 
     def move(self, location_delta: mod_geo.LocationDelta) -> None:
-        """
-        Moves each point in the gpx file (routes, waypoints, tracks).
-
-        Parameters
-        ----------
-        location_delta: LocationDelta
-            LocationDelta to move each point
-        """
-        for route in self.routes:
-            route.move(location_delta)
-
         for waypoint in self.waypoints:
             waypoint.move(location_delta)
 
-        for track in self.tracks:
-            track.move(location_delta)
-
     def to_xml(self, version: Optional[str]=None, prettyprint: bool=True) -> str:
-        """
-        FIXME: Note, this method will change self.version
-        """
         if not version:
             if self.version:
                 version = self.version
@@ -2712,18 +2435,16 @@ class GPX:
         return f'<?xml version="1.0" encoding="UTF-8"?>\n{content.strip()}'
 
     def has_times(self) -> bool:
-        """ See GPXTrackSegment.has_times() """
         if not self.tracks:
             return False
 
-        result = True
+        result = False
         for track in self.tracks:
-            result = result and track.has_times()
+            result = result or track.has_times()
 
         return result
 
     def has_elevations(self) -> bool:
-        """ See GPXTrackSegment.has_elevations()) """
         if not self.tracks:
             return False
 
