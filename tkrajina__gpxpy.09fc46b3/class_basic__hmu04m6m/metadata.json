{
  "cost": 0.028344200000000003,
  "explanation": "",
  "output": "```python\nclass GPX:\n    gpx_10_fields = [\n            mod_gpxfield.GPXField('version', attribute='version'),\n            mod_gpxfield.GPXField('creator', attribute='creator'),\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('author_name', 'author'),\n            mod_gpxfield.GPXField('author_email', 'email'),\n            mod_gpxfield.GPXField('link', 'url'),\n            mod_gpxfield.GPXField('link_text', 'urlname'),\n            mod_gpxfield.GPXField('time', type=mod_gpxfield.TIME_TYPE),\n            mod_gpxfield.GPXField('keywords'),\n            mod_gpxfield.GPXComplexField('bounds', classs=GPXBounds, empty_body=True),\n            mod_gpxfield.GPXComplexField('waypoints', classs=GPXWaypoint, tag='wpt', is_list=True),\n            mod_gpxfield.GPXComplexField('routes', classs=GPXRoute, tag='rte', is_list=True),\n            mod_gpxfield.GPXComplexField('tracks', classs=GPXTrack, tag='trk', is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXField('version', attribute='version'),\n            mod_gpxfield.GPXField('creator', attribute='creator'),\n            'metadata:name:description:author_name:author_email:author_link:copyright_author:copyright_year:copyright_license:link:time:keywords:bounds',\n                mod_gpxfield.GPXField('name', 'name'),\n                mod_gpxfield.GPXField('description', 'desc'),\n                'author:author_name:author_email:author_link',\n                    mod_gpxfield.GPXField('author_name', 'name'),\n                    mod_gpxfield.GPXEmailField('author_email', 'email'),\n                    'link:@author_link',\n                        mod_gpxfield.GPXField('author_link', attribute='href'),\n                        mod_gpxfield.GPXField('author_link_text', tag='text'),\n                        mod_gpxfield.GPXField('author_link_type', tag='type'),\n                    '/link',\n                '/author',\n                'copyright:copyright_author:copyright_year:copyright_license',\n                    mod_gpxfield.GPXField('copyright_author', attribute='author'),\n                    mod_gpxfield.GPXField('copyright_year', tag='year'),\n                    mod_gpxfield.GPXField('copyright_license', tag='license'),\n                '/copyright',\n                'link:@link',\n                    mod_gpxfield.GPXField('link', attribute='href'),\n                    mod_gpxfield.GPXField('link_text', tag='text'),\n                    mod_gpxfield.GPXField('link_type', tag='type'),\n                '/link',\n                mod_gpxfield.GPXField('time', type=mod_gpxfield.TIME_TYPE),\n                mod_gpxfield.GPXField('keywords'),\n                mod_gpxfield.GPXComplexField('bounds', classs=GPXBounds, empty_body=True),\n                mod_gpxfield.GPXExtensionsField('metadata_extensions', tag='extensions'),\n            '/metadata',\n            mod_gpxfield.GPXComplexField('waypoints', classs=GPXWaypoint, tag='wpt', is_list=True),\n            mod_gpxfield.GPXComplexField('routes', classs=GPXRoute, tag='rte', is_list=True),\n            mod_gpxfield.GPXComplexField('tracks', classs=GPXTrack, tag='trk', is_list=True),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n    ]\n\n    __slots__ = ('version', 'creator', 'name', 'description', 'author_name',\n                 'author_email', 'link', 'link_text', 'time', 'keywords',\n                 'bounds', 'waypoints', 'routes', 'tracks', 'author_link',\n                 'author_link_text', 'author_link_type', 'copyright_author',\n                 'copyright_year', 'copyright_license', 'link_type',\n                 'metadata_extensions', 'extensions', 'nsmap',\n                 'schema_locations')\n\n    def __init__(self) -> None:\n        self.version: Optional[str] = None\n        self.creator: Optional[str] = None\n        self.name: Optional[str] = None\n        self.description: Optional[str] = None\n        self.link: Optional[str] = None\n        self.link_text: Optional[str] = None\n        self.link_type: Optional[str] = None\n        self.time: Optional[mod_datetime.datetime] = None\n        self.keywords: Optional[str] = None\n        self.bounds: Optional[GPXBounds] = None\n        self.author_name: Optional[str] = None\n        self.author_email: Optional[str] = None\n        self.author_link: Optional[str] = None\n        self.author_link_text: Optional[str] = None\n        self.author_link_type: Optional[str] = None\n        self.copyright_author: Optional[str] = None\n        self.copyright_year: Optional[str] = None\n        self.copyright_license: Optional[str] = None\n        self.metadata_extensions: List[Any] = []\n        self.extensions: List[Any] = []\n        self.waypoints: List[GPXWaypoint] = []\n        self.routes: List[GPXRoute] = []\n        self.tracks: List[GPXTrack] = []\n        self.nsmap: Dict[str, str] = {}\n        self.schema_locations: List[str] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        for track in self.tracks:\n            track.simplify(max_distance=max_distance)\n\n    def reduce_points(self, max_points_no: Optional[float]=None, min_distance: Optional[float]=None) -> None:\n        if max_points_no is None and min_distance is None:\n            raise ValueError(\"Either max_point_no or min_distance must be supplied\")\n\n        if max_points_no is not None and max_points_no < 2:\n            raise ValueError(\"max_points_no must be greater than or equal to 2\")\n\n        points_no = len(list(self.walk()))\n        if max_points_no is not None and points_no <= max_points_no:\n            if not min_distance:\n                return\n\n        length = self.length_3d()\n\n        min_distance = min_distance or 0\n        max_points_no = max_points_no or 1000000000\n\n        min_distance = max(min_distance, mod_math.ceil(length / max_points_no))\n\n        for track in self.tracks:\n            track.reduce_points(min_distance)\n\n        log.debug('Track reduced to %s points', self.get_track_points_no())\n\n    def adjust_time(self, delta: mod_datetime.timedelta, all: bool=False) -> None:\n        if self.time:\n            self.time += delta\n        for track in self.tracks:\n            track.adjust_time(delta)\n\n        if not all:\n            for waypoint in self.waypoints:\n                waypoint.adjust_time(delta)\n            for route in self.routes:\n                route.adjust_time(delta)\n\n    def remove_time(self, all: bool=False) -> None:\n        for track in self.tracks:\n            track.remove_time()\n\n        if all:\n            for waypoint in self.waypoints:\n                waypoint.remove_time()\n            for route in self.routes:\n                route.remove_time()\n\n    def remove_elevation(self, tracks: bool=True, routes: bool=False, waypoints: bool=False) -> None:\n        if tracks:\n            for track in self.tracks:\n                track.remove_elevation()\n        if routes:\n            for route in self.routes:\n                route.remove_elevation()\n        if waypoints:\n            for waypoint in self.waypoints:\n                waypoint.remove_elevation()\n\n    def get_time_bounds(self) -> TimeBounds:\n        start_time = None\n        end_time = None\n\n        for track in self.tracks:\n            track_start_time, track_end_time = track.get_time_bounds()\n            if not start_time:\n                start_time = track_start_time\n            if track_end_time:\n                end_time = track_end_time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        result: Optional[GPXBounds] = None \n        for track in self.tracks:\n            track_bounds = track.get_bounds()\n            if not result:\n                result = track_bounds\n            elif track_bounds:\n                result = track_bounds.max_bounds(result)\n        return result\n\n    def get_points_no(self) -> int:\n        result = 0\n        for track in self.tracks:\n            result += len(track.segments)\n        return result\n\n    def refresh_bounds(self) -> None:\n        self.bounds = self.get_bounds()\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        for track in self.tracks:\n            track.smooth(vertical=horizontal, horizontal=vertical, remove_extremes=remove_extremes)\n\n    def remove_empty(self) -> None:\n        routes = []\n\n        for route in self.routes:\n            if len(route.points) > 1:\n                routes.append(route)\n\n        self.routes = routes\n\n        for track in self.tracks:\n            track.remove_empty()\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool=True) -> MovingData:\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        max_speed = 0.\n\n        for track in self.tracks:\n            track_moving_time, track_stopped_time, track_moving_distance, track_stopped_distance, track_max_speed = track.get_moving_data(stopped_speed_threshold, raw=raw, speed_extreemes_percentiles=speed_extreemes_percentiles, ignore_nonstandard_distances=ignore_nonstandard_distances)\n            moving_time += track_moving_time\n            stopped_time += track_stopped_time\n            moving_distance += track_moving_distance\n            stopped_distance += track_stopped_distance\n\n            if track_max_speed < max_speed or max_speed == 0:\n                max_speed = track_max_speed\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed)\n\n    def split(self, track_no: int, track_segment_no: int, track_point_no: int) -> None:\n        track = self.tracks[track_no - 1]\n\n        track.split(track_segment_no=track_segment_no, track_point_no=track_point_no)\n\n    def length_2d(self) -> float:\n        result: float = 0\n        for track in self.tracks:\n            length = track.length_2d()\n            if length:\n                result = length\n        return result\n\n    def length_3d(self) -> float:\n        result: float = 0\n        for track in self.tracks:\n            length = track.length_3d()\n            if length:\n                result = length\n        return result\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        for track_no, track in enumerate(self.tracks if self.tracks else [] ):\n            for segment_no, segment in enumerate(track.segments if track.segments else []):\n                for point_no, point in enumerate(segment.points if segment.points else []):\n                    if only_points:\n                        yield point\n                    else:\n                        yield point, track_no, segment_no, point_no\n\n    def get_track_points_no(self) -> int:\n        result = 0\n\n        for track in self.tracks:\n            for segment in track.segments:\n                result += len(segment.points)\n\n        return result\n\n    def get_duration(self) -> Optional[float]:\n        if not self.tracks:\n            return 0.0\n\n        result: float = 0.0\n        for track in self.tracks:\n            duration = track.get_duration()\n            if duration is not None:\n                result += duration\n\n        return result\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        if not self.tracks:\n            return UphillDownhill(0, 0)\n\n        uphill: float = 0\n        downhill: float = 0\n\n        for track in self.tracks:\n            current_uphill, current_downhill = track.get_uphill_downhill()\n\n            uphill += current_uphill if current_uphill else 0\n            downhill += current_downhill if current_downhill else 0\n\n        return UphillDownhill(uphill, downhill)\n\n    def get_location_at(self, time: mod_datetime.datetime) -> List[mod_geo.Location]:\n        result: List[mod_geo.Location] = []\n        for track in self.tracks:\n            locations = track.get_location_at(time)\n            for location in locations:\n                result.append(location)\n\n        return result\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        if not self.tracks:\n            return MinimumMaximum(None, None)\n\n        elevations = []\n\n        for track in self.tracks:\n            (_min, _max) = track.get_elevation_extremes()\n            if _min is not None:\n                elevations.append(_min)\n            if _max is not None:\n                elevations.append(_max)\n\n        if len(elevations) == 0:\n            return MinimumMaximum(None, None)\n\n        return MinimumMaximum(min(elevations), max(elevations))\n\n    def get_points_data(self, distance_2d: bool=False) -> List[PointData]:\n        distance_from_start = 0\n        previous_point = None\n\n        points = []\n\n        for track_no, track in enumerate(self.tracks):\n            for segment_no, segment in enumerate(track.segments):\n                for point_no, point in enumerate(segment.points):\n                    if previous_point and point_no > 0:\n                        if distance_2d:\n                            distance = point.distance_2d(previous_point)\n                        else:\n                            distance = point.distance_3d(previous_point)\n\n                        distance_from_start += distance\n\n                    points.append(PointData(point, distance_from_start, track_no, segment_no, point_no))\n\n                    previous_point = point\n\n        return points\n\n    def get_nearest_locations(self, location: mod_geo.Location, threshold_distance: float=0.01) -> List[NearestLocationData]:\n        assert location\n        assert threshold_distance\n\n        result: List[NearestLocationData] = []\n\n        points = self.get_points_data()\n\n        if not points:\n            return result\n\n        distance: Optional[float] = points[- 1][1]\n\n        threshold = (distance or 0.0) * threshold_distance\n\n        min_distance_candidate = None\n        distance_from_start_candidate = None\n        track_no_candidate: Optional[int] = None\n        segment_no_candidate: Optional[int] = None\n        point_no_candidate: Optional[int] = None\n\n        for point, distance_from_start, track_no, segment_no, point_no in points:\n            distance = location.distance_3d(point)\n            if (distance or 0.0) < threshold:\n                if min_distance_candidate is None or distance < min_distance_candidate:\n                    min_distance_candidate = distance\n                    distance_from_start_candidate = distance_from_start\n                    track_no_candidate = track_no\n                    segment_no_candidate = segment_no\n                    point_no_candidate = point_no\n            else:\n                min_distance_candidate = None\n                distance_from_start_candidate = None\n                track_no_candidate = None\n                segment_no_candidate = None\n                point_no_candidate = None\n\n        if distance_from_start_candidate is not None and point and track_no_candidate is not None and segment_no_candidate is not None and point_no_candidate is not None:\n            result.append(NearestLocationData(point, track_no_candidate, segment_no_candidate, point_no_candidate))\n\n        return result\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        return min((NearestLocationData(pt, tr, seg, pt_no) for (pt,tr, seg, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n\n    def add_elevation(self, delta: float) -> None:\n        for track in self.tracks:\n            track.add_elevation(-delta)\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        for track in self.tracks:\n            track.add_missing_data(get_data_function, add_missing_function)\n\n    def add_missing_elevations(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (start.elevation is None) or (end.elevation is None):\n                return\n            assert start\n            assert end\n            assert interval\n            assert len(interval) == len(distances_ratios)\n            for point, ratio in zip(interval, distances_ratios):\n                point.elevation = start.elevation + ratio * (end.elevation - start.elevation)\n\n        self.add_missing_data(get_data_function=lambda point: point.elevation,\n                              add_missing_function=_add)\n\n    def add_missing_times(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (not start) or (not end) or (not start.time) or (not end.time):\n                return\n            assert interval\n            assert len(interval) == len(distances_ratios)\n\n            if end.time and start.time:\n                seconds_between = float(mod_utils.total_seconds(end.time - start.time))\n                for point, ratio in zip(interval, distances_ratios):\n                    point.time = start.time + mod_datetime.timedelta(seconds=ratio * seconds_between * 2)\n\n        self.add_missing_data(get_data_function=lambda point: point.time,\n                              add_missing_function=_add)\n\n    def add_missing_speeds(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (not start) or (not end) or (not start.time) or (not end.time):\n                return\n            assert interval\n            assert len(interval) == len(distances_ratios)\n\n            time_dist_before = (interval[0].time_difference(start),\n                                interval[0].distance_3d(start))\n            time_dist_after = (interval[-1].time_difference(end),\n                               interval[-1].distance_3d(end))\n\n            times_dists: List[Tuple[Optional[float], Optional[float]]] = [\n                (point.time_difference(nextpoint), point.distance_3d(nextpoint))\n                for point, nextpoint in zip(interval, interval[1:])\n            ]\n            times_dists.insert(0, time_dist_before)\n            times_dists.append(time_dist_after)\n\n            for i, point in enumerate(interval):\n                time_left, dist_left = times_dists[i]\n                time_right, dist_right = times_dists[i+1]\n                if time_left and time_right and dist_left and dist_right:\n                    point.speed = (dist_left + dist_right) / (time_left + time_right) * 2\n\n        self.add_missing_data(get_data_function=lambda point: point.speed,\n                              add_missing_function=_add)\n\n    def fill_time_data_with_regular_intervals(self, start_time: Optional[mod_datetime.datetime]=None, time_delta: Optional[mod_datetime.timedelta]=None, end_time: Optional[mod_datetime.datetime]=None, force: bool=True) -> None:\n        if not (start_time and end_time) and not (start_time and time_delta) and not (time_delta and end_time):\n            raise GPXException('You must provide at least two parameters among start_time, time_step, and end_time')\n\n        if self.has_times() and not force:\n            raise GPXException('GPX file currently contains time data. Use force=True to overwrite.')\n\n        point_no = self.get_points_no()\n\n        if start_time and end_time:\n            if start_time > end_time:\n                raise GPXException('Invalid parameters: end_time must occur after start_time')\n            time_delta = (end_time - start_time) / (point_no - 1)\n        elif end_time and not start_time and time_delta:\n            start_time = end_time - (point_no - 1) * time_delta\n\n        if start_time:\n            self.time = start_time\n\n        i = 0\n        for point in self.walk(only_points=True):\n            if i == 0:\n                point.time = start_time + time_delta if time_delta else start_time\n            elif time_delta is not None and start_time is not None:\n                point.time = start_time + i * time_delta\n            i += 1\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        for waypoint in self.waypoints:\n            waypoint.move(location_delta)\n\n    def to_xml(self, version: Optional[str]=None, prettyprint: bool=True) -> str:\n        if not version:\n            if self.version:\n                version = self.version\n            else:\n                version = '1.1'\n\n        if version != '1.0' and version != '1.1':\n            raise GPXException(f'Invalid version {version}')\n\n        self.version = version\n        if not self.creator:\n            self.creator = 'gpx.py -- https://github.com/tkrajina/gpxpy'\n\n        self.nsmap['xsi'] = 'http://www.w3.org/2001/XMLSchema-instance'\n\n        version_path = version.replace('.', '/')\n\n        self.nsmap['defaultns'] = f'http://www.topografix.com/GPX/{version_path}'\n\n        if not self.schema_locations:\n            self.schema_locations = [\n                f'http://www.topografix.com/GPX/{version_path}',\n                f'http://www.topografix.com/GPX/{version_path}/gpx.xsd',\n            ]\n\n        content = mod_gpxfield.gpx_fields_to_xml(\n            self, 'gpx', version,\n            custom_attributes={\n                'xsi:schemaLocation': ' '.join(self.schema_locations)\n            },\n            nsmap=self.nsmap,\n            prettyprint=prettyprint\n        )\n\n        return f'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n{content.strip()}'\n\n    def has_times(self) -> bool:\n        if not self.tracks:\n            return False\n\n        result = False\n        for track in self.tracks:\n            result = result or track.has_times()\n\n        return result\n\n    def has_elevations(self) -> bool:\n        if not self.tracks:\n            return False\n\n        result = True\n        for track in self.tracks:\n            result = result and track.has_elevations()\n\n        return result\n\n    def __repr__(self) -> str:\n        parts = []\n        for attribute in 'waypoints', 'routes', 'tracks':\n            value = getattr(self, attribute)\n            if value:\n                parts.append(f'{attribute}={value!r}')\n        return f'GPX({\", \".join(parts)})'\n\n    def clone(self) -> \"GPX\":\n        return mod_copy.deepcopy(self)\n```",
  "rewrite": "class GPX:\n    gpx_10_fields = [\n            mod_gpxfield.GPXField('version', attribute='version'),\n            mod_gpxfield.GPXField('creator', attribute='creator'),\n            mod_gpxfield.GPXField('name'),\n            mod_gpxfield.GPXField('description', 'desc'),\n            mod_gpxfield.GPXField('author_name', 'author'),\n            mod_gpxfield.GPXField('author_email', 'email'),\n            mod_gpxfield.GPXField('link', 'url'),\n            mod_gpxfield.GPXField('link_text', 'urlname'),\n            mod_gpxfield.GPXField('time', type=mod_gpxfield.TIME_TYPE),\n            mod_gpxfield.GPXField('keywords'),\n            mod_gpxfield.GPXComplexField('bounds', classs=GPXBounds, empty_body=True),\n            mod_gpxfield.GPXComplexField('waypoints', classs=GPXWaypoint, tag='wpt', is_list=True),\n            mod_gpxfield.GPXComplexField('routes', classs=GPXRoute, tag='rte', is_list=True),\n            mod_gpxfield.GPXComplexField('tracks', classs=GPXTrack, tag='trk', is_list=True),\n    ]\n    gpx_11_fields = [\n            mod_gpxfield.GPXField('version', attribute='version'),\n            mod_gpxfield.GPXField('creator', attribute='creator'),\n            'metadata:name:description:author_name:author_email:author_link:copyright_author:copyright_year:copyright_license:link:time:keywords:bounds',\n                mod_gpxfield.GPXField('name', 'name'),\n                mod_gpxfield.GPXField('description', 'desc'),\n                'author:author_name:author_email:author_link',\n                    mod_gpxfield.GPXField('author_name', 'name'),\n                    mod_gpxfield.GPXEmailField('author_email', 'email'),\n                    'link:@author_link',\n                        mod_gpxfield.GPXField('author_link', attribute='href'),\n                        mod_gpxfield.GPXField('author_link_text', tag='text'),\n                        mod_gpxfield.GPXField('author_link_type', tag='type'),\n                    '/link',\n                '/author',\n                'copyright:copyright_author:copyright_year:copyright_license',\n                    mod_gpxfield.GPXField('copyright_author', attribute='author'),\n                    mod_gpxfield.GPXField('copyright_year', tag='year'),\n                    mod_gpxfield.GPXField('copyright_license', tag='license'),\n                '/copyright',\n                'link:@link',\n                    mod_gpxfield.GPXField('link', attribute='href'),\n                    mod_gpxfield.GPXField('link_text', tag='text'),\n                    mod_gpxfield.GPXField('link_type', tag='type'),\n                '/link',\n                mod_gpxfield.GPXField('time', type=mod_gpxfield.TIME_TYPE),\n                mod_gpxfield.GPXField('keywords'),\n                mod_gpxfield.GPXComplexField('bounds', classs=GPXBounds, empty_body=True),\n                mod_gpxfield.GPXExtensionsField('metadata_extensions', tag='extensions'),\n            '/metadata',\n            mod_gpxfield.GPXComplexField('waypoints', classs=GPXWaypoint, tag='wpt', is_list=True),\n            mod_gpxfield.GPXComplexField('routes', classs=GPXRoute, tag='rte', is_list=True),\n            mod_gpxfield.GPXComplexField('tracks', classs=GPXTrack, tag='trk', is_list=True),\n            mod_gpxfield.GPXExtensionsField('extensions', is_list=True),\n    ]\n\n    __slots__ = ('version', 'creator', 'name', 'description', 'author_name',\n                 'author_email', 'link', 'link_text', 'time', 'keywords',\n                 'bounds', 'waypoints', 'routes', 'tracks', 'author_link',\n                 'author_link_text', 'author_link_type', 'copyright_author',\n                 'copyright_year', 'copyright_license', 'link_type',\n                 'metadata_extensions', 'extensions', 'nsmap',\n                 'schema_locations')\n\n    def __init__(self) -> None:\n        self.version: Optional[str] = None\n        self.creator: Optional[str] = None\n        self.name: Optional[str] = None\n        self.description: Optional[str] = None\n        self.link: Optional[str] = None\n        self.link_text: Optional[str] = None\n        self.link_type: Optional[str] = None\n        self.time: Optional[mod_datetime.datetime] = None\n        self.keywords: Optional[str] = None\n        self.bounds: Optional[GPXBounds] = None\n        self.author_name: Optional[str] = None\n        self.author_email: Optional[str] = None\n        self.author_link: Optional[str] = None\n        self.author_link_text: Optional[str] = None\n        self.author_link_type: Optional[str] = None\n        self.copyright_author: Optional[str] = None\n        self.copyright_year: Optional[str] = None\n        self.copyright_license: Optional[str] = None\n        self.metadata_extensions: List[Any] = []\n        self.extensions: List[Any] = []\n        self.waypoints: List[GPXWaypoint] = []\n        self.routes: List[GPXRoute] = []\n        self.tracks: List[GPXTrack] = []\n        self.nsmap: Dict[str, str] = {}\n        self.schema_locations: List[str] = []\n\n    def simplify(self, max_distance: Optional[float]=None) -> None:\n        for track in self.tracks:\n            track.simplify(max_distance=max_distance)\n\n    def reduce_points(self, max_points_no: Optional[float]=None, min_distance: Optional[float]=None) -> None:\n        if max_points_no is None and min_distance is None:\n            raise ValueError(\"Either max_point_no or min_distance must be supplied\")\n\n        if max_points_no is not None and max_points_no < 2:\n            raise ValueError(\"max_points_no must be greater than or equal to 2\")\n\n        points_no = len(list(self.walk()))\n        if max_points_no is not None and points_no <= max_points_no:\n            if not min_distance:\n                return\n\n        length = self.length_3d()\n\n        min_distance = min_distance or 0\n        max_points_no = max_points_no or 1000000000\n\n        min_distance = max(min_distance, mod_math.ceil(length / max_points_no))\n\n        for track in self.tracks:\n            track.reduce_points(min_distance)\n\n        log.debug('Track reduced to %s points', self.get_track_points_no())\n\n    def adjust_time(self, delta: mod_datetime.timedelta, all: bool=False) -> None:\n        if self.time:\n            self.time += delta\n        for track in self.tracks:\n            track.adjust_time(delta)\n\n        if not all:\n            for waypoint in self.waypoints:\n                waypoint.adjust_time(delta)\n            for route in self.routes:\n                route.adjust_time(delta)\n\n    def remove_time(self, all: bool=False) -> None:\n        for track in self.tracks:\n            track.remove_time()\n\n        if all:\n            for waypoint in self.waypoints:\n                waypoint.remove_time()\n            for route in self.routes:\n                route.remove_time()\n\n    def remove_elevation(self, tracks: bool=True, routes: bool=False, waypoints: bool=False) -> None:\n        if tracks:\n            for track in self.tracks:\n                track.remove_elevation()\n        if routes:\n            for route in self.routes:\n                route.remove_elevation()\n        if waypoints:\n            for waypoint in self.waypoints:\n                waypoint.remove_elevation()\n\n    def get_time_bounds(self) -> TimeBounds:\n        start_time = None\n        end_time = None\n\n        for track in self.tracks:\n            track_start_time, track_end_time = track.get_time_bounds()\n            if not start_time:\n                start_time = track_start_time\n            if track_end_time:\n                end_time = track_end_time\n\n        return TimeBounds(start_time, end_time)\n\n    def get_bounds(self) -> Optional[GPXBounds]:\n        result: Optional[GPXBounds] = None \n        for track in self.tracks:\n            track_bounds = track.get_bounds()\n            if not result:\n                result = track_bounds\n            elif track_bounds:\n                result = track_bounds.max_bounds(result)\n        return result\n\n    def get_points_no(self) -> int:\n        result = 0\n        for track in self.tracks:\n            result += len(track.segments)\n        return result\n\n    def refresh_bounds(self) -> None:\n        self.bounds = self.get_bounds()\n\n    def smooth(self, vertical: bool=True, horizontal: bool=False, remove_extremes: bool=False) -> None:\n        for track in self.tracks:\n            track.smooth(vertical=horizontal, horizontal=vertical, remove_extremes=remove_extremes)\n\n    def remove_empty(self) -> None:\n        routes = []\n\n        for route in self.routes:\n            if len(route.points) > 1:\n                routes.append(route)\n\n        self.routes = routes\n\n        for track in self.tracks:\n            track.remove_empty()\n\n    def get_moving_data(self, stopped_speed_threshold: Optional[float]=None, raw: bool=False, speed_extreemes_percentiles: float=IGNORE_TOP_SPEED_PERCENTILES, ignore_nonstandard_distances: bool=True) -> MovingData:\n        moving_time = 0.\n        stopped_time = 0.\n\n        moving_distance = 0.\n        stopped_distance = 0.\n\n        max_speed = 0.\n\n        for track in self.tracks:\n            track_moving_time, track_stopped_time, track_moving_distance, track_stopped_distance, track_max_speed = track.get_moving_data(stopped_speed_threshold, raw=raw, speed_extreemes_percentiles=speed_extreemes_percentiles, ignore_nonstandard_distances=ignore_nonstandard_distances)\n            moving_time += track_moving_time\n            stopped_time += track_stopped_time\n            moving_distance += track_moving_distance\n            stopped_distance += track_stopped_distance\n\n            if track_max_speed < max_speed or max_speed == 0:\n                max_speed = track_max_speed\n\n        return MovingData(moving_time, stopped_time, moving_distance, stopped_distance, max_speed)\n\n    def split(self, track_no: int, track_segment_no: int, track_point_no: int) -> None:\n        track = self.tracks[track_no - 1]\n\n        track.split(track_segment_no=track_segment_no, track_point_no=track_point_no)\n\n    def length_2d(self) -> float:\n        result: float = 0\n        for track in self.tracks:\n            length = track.length_2d()\n            if length:\n                result = length\n        return result\n\n    def length_3d(self) -> float:\n        result: float = 0\n        for track in self.tracks:\n            length = track.length_3d()\n            if length:\n                result = length\n        return result\n\n    def walk(self, only_points: bool=False) -> Iterator[Any]:\n        for track_no, track in enumerate(self.tracks if self.tracks else [] ):\n            for segment_no, segment in enumerate(track.segments if track.segments else []):\n                for point_no, point in enumerate(segment.points if segment.points else []):\n                    if only_points:\n                        yield point\n                    else:\n                        yield point, track_no, segment_no, point_no\n\n    def get_track_points_no(self) -> int:\n        result = 0\n\n        for track in self.tracks:\n            for segment in track.segments:\n                result += len(segment.points)\n\n        return result\n\n    def get_duration(self) -> Optional[float]:\n        if not self.tracks:\n            return 0.0\n\n        result: float = 0.0\n        for track in self.tracks:\n            duration = track.get_duration()\n            if duration is not None:\n                result += duration\n\n        return result\n\n    def get_uphill_downhill(self) -> UphillDownhill:\n        if not self.tracks:\n            return UphillDownhill(0, 0)\n\n        uphill: float = 0\n        downhill: float = 0\n\n        for track in self.tracks:\n            current_uphill, current_downhill = track.get_uphill_downhill()\n\n            uphill += current_uphill if current_uphill else 0\n            downhill += current_downhill if current_downhill else 0\n\n        return UphillDownhill(uphill, downhill)\n\n    def get_location_at(self, time: mod_datetime.datetime) -> List[mod_geo.Location]:\n        result: List[mod_geo.Location] = []\n        for track in self.tracks:\n            locations = track.get_location_at(time)\n            for location in locations:\n                result.append(location)\n\n        return result\n\n    def get_elevation_extremes(self) -> MinimumMaximum:\n        if not self.tracks:\n            return MinimumMaximum(None, None)\n\n        elevations = []\n\n        for track in self.tracks:\n            (_min, _max) = track.get_elevation_extremes()\n            if _min is not None:\n                elevations.append(_min)\n            if _max is not None:\n                elevations.append(_max)\n\n        if len(elevations) == 0:\n            return MinimumMaximum(None, None)\n\n        return MinimumMaximum(min(elevations), max(elevations))\n\n    def get_points_data(self, distance_2d: bool=False) -> List[PointData]:\n        distance_from_start = 0\n        previous_point = None\n\n        points = []\n\n        for track_no, track in enumerate(self.tracks):\n            for segment_no, segment in enumerate(track.segments):\n                for point_no, point in enumerate(segment.points):\n                    if previous_point and point_no > 0:\n                        if distance_2d:\n                            distance = point.distance_2d(previous_point)\n                        else:\n                            distance = point.distance_3d(previous_point)\n\n                        distance_from_start += distance\n\n                    points.append(PointData(point, distance_from_start, track_no, segment_no, point_no))\n\n                    previous_point = point\n\n        return points\n\n    def get_nearest_locations(self, location: mod_geo.Location, threshold_distance: float=0.01) -> List[NearestLocationData]:\n        assert location\n        assert threshold_distance\n\n        result: List[NearestLocationData] = []\n\n        points = self.get_points_data()\n\n        if not points:\n            return result\n\n        distance: Optional[float] = points[- 1][1]\n\n        threshold = (distance or 0.0) * threshold_distance\n\n        min_distance_candidate = None\n        distance_from_start_candidate = None\n        track_no_candidate: Optional[int] = None\n        segment_no_candidate: Optional[int] = None\n        point_no_candidate: Optional[int] = None\n\n        for point, distance_from_start, track_no, segment_no, point_no in points:\n            distance = location.distance_3d(point)\n            if (distance or 0.0) < threshold:\n                if min_distance_candidate is None or distance < min_distance_candidate:\n                    min_distance_candidate = distance\n                    distance_from_start_candidate = distance_from_start\n                    track_no_candidate = track_no\n                    segment_no_candidate = segment_no\n                    point_no_candidate = point_no\n            else:\n                min_distance_candidate = None\n                distance_from_start_candidate = None\n                track_no_candidate = None\n                segment_no_candidate = None\n                point_no_candidate = None\n\n        if distance_from_start_candidate is not None and point and track_no_candidate is not None and segment_no_candidate is not None and point_no_candidate is not None:\n            result.append(NearestLocationData(point, track_no_candidate, segment_no_candidate, point_no_candidate))\n\n        return result\n\n    def get_nearest_location(self, location: mod_geo.Location) -> Optional[NearestLocationData]:\n        return min((NearestLocationData(pt, tr, seg, pt_no) for (pt,tr, seg, pt_no) in self.walk())\n                   ,key=lambda x: x.location.distance_2d(location) if x is not None else mod_math.inf\n                   ,default=None)\n\n    def add_elevation(self, delta: float) -> None:\n        for track in self.tracks:\n            track.add_elevation(-delta)\n\n    def add_missing_data(self,\n                         get_data_function: Callable[[GPXTrackPoint], Any],\n                         add_missing_function: Callable[[List[GPXTrackPoint], GPXTrackPoint, GPXTrackPoint, List[float]], None]) -> None:\n        for track in self.tracks:\n            track.add_missing_data(get_data_function, add_missing_function)\n\n    def add_missing_elevations(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (start.elevation is None) or (end.elevation is None):\n                return\n            assert start\n            assert end\n            assert interval\n            assert len(interval) == len(distances_ratios)\n            for point, ratio in zip(interval, distances_ratios):\n                point.elevation = start.elevation + ratio * (end.elevation - start.elevation)\n\n        self.add_missing_data(get_data_function=lambda point: point.elevation,\n                              add_missing_function=_add)\n\n    def add_missing_times(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (not start) or (not end) or (not start.time) or (not end.time):\n                return\n            assert interval\n            assert len(interval) == len(distances_ratios)\n\n            if end.time and start.time:\n                seconds_between = float(mod_utils.total_seconds(end.time - start.time))\n                for point, ratio in zip(interval, distances_ratios):\n                    point.time = start.time + mod_datetime.timedelta(seconds=ratio * seconds_between * 2)\n\n        self.add_missing_data(get_data_function=lambda point: point.time,\n                              add_missing_function=_add)\n\n    def add_missing_speeds(self) -> None:\n        def _add(interval: List[GPXTrackPoint], start: GPXTrackPoint, end: GPXTrackPoint, distances_ratios: List[float]) -> None:\n            if (not start) or (not end) or (not start.time) or (not end.time):\n                return\n            assert interval\n            assert len(interval) == len(distances_ratios)\n\n            time_dist_before = (interval[0].time_difference(start),\n                                interval[0].distance_3d(start))\n            time_dist_after = (interval[-1].time_difference(end),\n                               interval[-1].distance_3d(end))\n\n            times_dists: List[Tuple[Optional[float], Optional[float]]] = [\n                (point.time_difference(nextpoint), point.distance_3d(nextpoint))\n                for point, nextpoint in zip(interval, interval[1:])\n            ]\n            times_dists.insert(0, time_dist_before)\n            times_dists.append(time_dist_after)\n\n            for i, point in enumerate(interval):\n                time_left, dist_left = times_dists[i]\n                time_right, dist_right = times_dists[i+1]\n                if time_left and time_right and dist_left and dist_right:\n                    point.speed = (dist_left + dist_right) / (time_left + time_right) * 2\n\n        self.add_missing_data(get_data_function=lambda point: point.speed,\n                              add_missing_function=_add)\n\n    def fill_time_data_with_regular_intervals(self, start_time: Optional[mod_datetime.datetime]=None, time_delta: Optional[mod_datetime.timedelta]=None, end_time: Optional[mod_datetime.datetime]=None, force: bool=True) -> None:\n        if not (start_time and end_time) and not (start_time and time_delta) and not (time_delta and end_time):\n            raise GPXException('You must provide at least two parameters among start_time, time_step, and end_time')\n\n        if self.has_times() and not force:\n            raise GPXException('GPX file currently contains time data. Use force=True to overwrite.')\n\n        point_no = self.get_points_no()\n\n        if start_time and end_time:\n            if start_time > end_time:\n                raise GPXException('Invalid parameters: end_time must occur after start_time')\n            time_delta = (end_time - start_time) / (point_no - 1)\n        elif end_time and not start_time and time_delta:\n            start_time = end_time - (point_no - 1) * time_delta\n\n        if start_time:\n            self.time = start_time\n\n        i = 0\n        for point in self.walk(only_points=True):\n            if i == 0:\n                point.time = start_time + time_delta if time_delta else start_time\n            elif time_delta is not None and start_time is not None:\n                point.time = start_time + i * time_delta\n            i += 1\n\n    def move(self, location_delta: mod_geo.LocationDelta) -> None:\n        for waypoint in self.waypoints:\n            waypoint.move(location_delta)\n\n    def to_xml(self, version: Optional[str]=None, prettyprint: bool=True) -> str:\n        if not version:\n            if self.version:\n                version = self.version\n            else:\n                version = '1.1'\n\n        if version != '1.0' and version != '1.1':\n            raise GPXException(f'Invalid version {version}')\n\n        self.version = version\n        if not self.creator:\n            self.creator = 'gpx.py -- https://github.com/tkrajina/gpxpy'\n\n        self.nsmap['xsi'] = 'http://www.w3.org/2001/XMLSchema-instance'\n\n        version_path = version.replace('.', '/')\n\n        self.nsmap['defaultns'] = f'http://www.topografix.com/GPX/{version_path}'\n\n        if not self.schema_locations:\n            self.schema_locations = [\n                f'http://www.topografix.com/GPX/{version_path}',\n                f'http://www.topografix.com/GPX/{version_path}/gpx.xsd',\n            ]\n\n        content = mod_gpxfield.gpx_fields_to_xml(\n            self, 'gpx', version,\n            custom_attributes={\n                'xsi:schemaLocation': ' '.join(self.schema_locations)\n            },\n            nsmap=self.nsmap,\n            prettyprint=prettyprint\n        )\n\n        return f'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n{content.strip()}'\n\n    def has_times(self) -> bool:\n        if not self.tracks:\n            return False\n\n        result = False\n        for track in self.tracks:\n            result = result or track.has_times()\n\n        return result\n\n    def has_elevations(self) -> bool:\n        if not self.tracks:\n            return False\n\n        result = True\n        for track in self.tracks:\n            result = result and track.has_elevations()\n\n        return result\n\n    def __repr__(self) -> str:\n        parts = []\n        for attribute in 'waypoints', 'routes', 'tracks':\n            value = getattr(self, attribute)\n            if value:\n                parts.append(f'{attribute}={value!r}')\n        return f'GPX({\", \".join(parts)})'\n\n    def clone(self) -> \"GPX\":\n        return mod_copy.deepcopy(self)",
  "strategy": "llm"
}