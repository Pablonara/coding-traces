{
  "cost": 0.005401700000000001,
  "explanation": "",
  "output": "```python\ndef calculate_max_speed(speeds_and_distances: List[Tuple[float, float]], extreemes_percentile: float, ignore_nonstandard_distances: bool) -> Optional[float]:\n    \"\"\"\n    Compute average distance and standard deviation for distance. Extremes\n    in distances are usually extremes in speeds, so we will ignore them,\n    here.\n\n    speeds_and_distances must be a list containing pairs of (speed, distance)\n    for every point in a track segment.\n\n    In many cases the top speeds are measurement errors. For that reason extreme speeds can be removed\n    with the extreemes_percentile (for example, a value of 0.05 will remove top 5%).\n    \"\"\"\n    assert speeds_and_distances\n    if len(speeds_and_distances) > 0:\n        assert len(speeds_and_distances[0]) == 2\n        # ...\n        assert len(speeds_and_distances[-1]) == 2\n\n    if not ignore_nonstandard_distances:\n        return max(x[0] or 0 for x in speeds_and_distances)\n\n    size = len(speeds_and_distances)\n\n    if size < 2:\n        # log.debug('Segment too small to compute speed, size=%s', size)\n        return None\n\n    distances = [x[1] for x in speeds_and_distances]\n    average_distance = sum(distances) / size\n    standard_distance_deviation = mod_math.sqrt(sum((distance - average_distance) ** 2 for distance in distances) / (size - 1))\n\n    # Ignore items where the distance is too big:\n    filtered_speeds_and_distances = [x for x in speeds_and_distances if abs(x[1] - average_distance) < standard_distance_deviation * 1.5]\n\n    # sort by speed:\n    speeds = [x[0] for x in filtered_speeds_and_distances]\n    if not speeds:\n        return None\n    speeds.sort()\n\n    # Even here there may be some extremes => ignore the last 5%:\n    index = int(len(speeds) * (1-extreemes_percentile))\n    if index >= len(speeds):\n        index = len(speeds) - 1\n\n    return speeds[index]\n```",
  "rewrite": "def calculate_max_speed(speeds_and_distances: List[Tuple[float, float]], extreemes_percentile: float, ignore_nonstandard_distances: bool) -> Optional[float]:\n    \"\"\"\n    Compute average distance and standard deviation for distance. Extremes\n    in distances are usually extremes in speeds, so we will ignore them,\n    here.\n\n    speeds_and_distances must be a list containing pairs of (speed, distance)\n    for every point in a track segment.\n\n    In many cases the top speeds are measurement errors. For that reason extreme speeds can be removed\n    with the extreemes_percentile (for example, a value of 0.05 will remove top 5%).\n    \"\"\"\n    assert speeds_and_distances\n    if len(speeds_and_distances) > 0:\n        assert len(speeds_and_distances[0]) == 2\n        # ...\n        assert len(speeds_and_distances[-1]) == 2\n\n    if not ignore_nonstandard_distances:\n        return max(x[0] or 0 for x in speeds_and_distances)\n\n    size = len(speeds_and_distances)\n\n    if size < 2:\n        # log.debug('Segment too small to compute speed, size=%s', size)\n        return None\n\n    distances = [x[1] for x in speeds_and_distances]\n    average_distance = sum(distances) / size\n    standard_distance_deviation = mod_math.sqrt(sum((distance - average_distance) ** 2 for distance in distances) / (size - 1))\n\n    # Ignore items where the distance is too big:\n    filtered_speeds_and_distances = [x for x in speeds_and_distances if abs(x[1] - average_distance) < standard_distance_deviation * 1.5]\n\n    # sort by speed:\n    speeds = [x[0] for x in filtered_speeds_and_distances]\n    if not speeds:\n        return None\n    speeds.sort()\n\n    # Even here there may be some extremes => ignore the last 5%:\n    index = int(len(speeds) * (1-extreemes_percentile))\n    if index >= len(speeds):\n        index = len(speeds) - 1\n\n    return speeds[index]",
  "strategy": "llm"
}