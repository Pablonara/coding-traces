{
  "cost": 0.006807140000000001,
  "explanation": "",
  "output": "```python\nclass BlackBody(Fittable1DModel):\n    \"\"\"\n    Blackbody model using the Planck function.\n\n    Parameters\n    ----------\n    temperature : `~astropy.units.Quantity` ['temperature']\n        Blackbody temperature.\n\n    scale : float or `~astropy.units.Quantity` ['dimensionless']\n        Scale factor\n\n    Notes\n    -----\n\n    Model formula:\n\n        .. math:: B_{\\\\nu}(T) = A \\\\frac{2 h \\\\nu^{3} / c^{2}}{exp(h \\\\nu / k T) - 1}\n\n    Examples\n    --------\n    >>> from astropy.modeling import models\n    >>> from astropy import units as u\n    >>> bb = models.BlackBody(temperature=5000*u.K)\n    >>> bb(6000 * u.AA)  # doctest: +FLOAT_CMP\n    <Quantity 1.53254685e-05 erg / (cm2 Hz s sr)>\n\n    .. plot::\n        :include-source:\n\n        import numpy as np\n        import matplotlib.pyplot as plt\n\n        from astropy.modeling.models import BlackBody\n        from astropy import units as u\n        from astropy.visualization import quantity_support\n\n        bb = BlackBody(temperature=5778*u.K)\n        wav = np.arange(1000, 110000) * u.AA\n        flux = bb(wav)\n\n        with quantity_support():\n            plt.figure()\n            plt.semilogx(wav, flux)\n            plt.axvline(bb.nu_max.to(u.AA, equivalencies=u.spectral()).value, ls='--')\n            plt.show()\n    \"\"\"\n\n    temperature = Parameter(default=5000.0, min=0, unit=u.K, description=\"Blackbody temperature\")\n    scale = Parameter(default=1.0, min=0, description=\"Scale factor\")\n\n    _input_units_allow_dimensionless = True\n\n    input_units_equivalencies = {'x': u.spectral()}\n\n    def evaluate(self, x, temperature, scale):\n        \"\"\"Evaluate the model.\n\n        Parameters\n        ----------\n        x : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['frequency']\n            Frequency at which to compute the blackbody. If no units are given,\n            this defaults to Hz.\n\n        temperature : float, `~numpy.ndarray`, or `~astropy.units.Quantity`\n            Temperature of the blackbody. If no units are given, this defaults\n            to Kelvin.\n\n        scale : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['dimensionless']\n            Desired scale for the blackbody.\n\n        Returns\n        -------\n        y : number or ndarray\n            Blackbody spectrum. The units are determined from the units of\n            ``scale``.\n\n        .. note::\n\n            Use `numpy.errstate` to suppress Numpy warnings, if desired.\n\n        .. warning::\n\n            Output values might contain ``nan`` and ``inf``.\n\n        Raises\n        ------\n        ValueError\n            Invalid temperature.\n\n        ZeroDivisionError\n            Wavelength is zero (when converting to frequency).\n        \"\"\"\n        if not isinstance(temperature, u.Quantity):\n            in_temp = u.Quantity(temperature, u.K)\n        else:\n            in_temp = temperature\n\n        with u.add_enabled_equivalencies(u.spectral() + u.temperature()):\n            freq = u.Quantity(x, u.Hz, dtype=np.float64)\n            temp = u.Quantity(in_temp, u.K)\n\n        bb_unit = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n        if hasattr(self.scale, \"unit\") and self.scale.unit is not None:\n            if not self.scale.unit.is_equivalent(bb_unit, u.spectral_density(x)):\n                raise ValueError(\n                    f\"scale units not surface brightness: {self.scale.unit}\"\n                )\n            if hasattr(scale, \"unit\"):\n                mult_scale = scale.value\n            else:\n                mult_scale = scale\n            bb_unit = self.scale.unit\n        else:\n            mult_scale = scale\n\n        if np.any(temp < 0):\n            raise ValueError(f\"Temperature should be positive: {temp}\")\n        if not np.all(np.isfinite(freq)) or np.any(freq <= 0):\n            warnings.warn(\n                \"Input contains invalid wavelength/frequency value(s)\",\n                AstropyUserWarning,\n            )\n\n        log_boltz = const.h * freq / (const.k_B * temp)\n        boltzm1 = np.expm1(log_boltz)\n\n        bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr\n\n        y = mult_scale * bb_nu.to(bb_unit, u.spectral_density(freq))\n\n        if hasattr(temperature, \"unit\"):\n            return y\n        return y.value\n\n    @property\n    def input_units(self):\n        return {self.inputs[0]: u.Hz}\n\n    def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n        return {\"temperature\": u.K}\n\n    @property\n    def bolometric_flux(self):\n        \"\"\"Bolometric flux.\"\"\"\n        native_bolflux = (\n            self.scale.value * const.sigma_sb * self.temperature ** 4 / np.pi\n        )\n        return native_bolflux.to(u.erg / (u.cm ** 2 * u.s))\n\n    @property\n    def lambda_max(self):\n        \"\"\"Peak wavelength when the curve is expressed as power density.\"\"\"\n        return const.b_wien / self.temperature\n\n    @property\n    def nu_max(self):\n        \"\"\"Peak frequency when the curve is expressed as power density.\"\"\"\n        return 2.8214391 * const.k_B * self.temperature / const.h\n```",
  "rewrite": "class BlackBody(Fittable1DModel):\n    \"\"\"\n    Blackbody model using the Planck function.\n\n    Parameters\n    ----------\n    temperature : `~astropy.units.Quantity` ['temperature']\n        Blackbody temperature.\n\n    scale : float or `~astropy.units.Quantity` ['dimensionless']\n        Scale factor\n\n    Notes\n    -----\n\n    Model formula:\n\n        .. math:: B_{\\\\nu}(T) = A \\\\frac{2 h \\\\nu^{3} / c^{2}}{exp(h \\\\nu / k T) - 1}\n\n    Examples\n    --------\n    >>> from astropy.modeling import models\n    >>> from astropy import units as u\n    >>> bb = models.BlackBody(temperature=5000*u.K)\n    >>> bb(6000 * u.AA)  # doctest: +FLOAT_CMP\n    <Quantity 1.53254685e-05 erg / (cm2 Hz s sr)>\n\n    .. plot::\n        :include-source:\n\n        import numpy as np\n        import matplotlib.pyplot as plt\n\n        from astropy.modeling.models import BlackBody\n        from astropy import units as u\n        from astropy.visualization import quantity_support\n\n        bb = BlackBody(temperature=5778*u.K)\n        wav = np.arange(1000, 110000) * u.AA\n        flux = bb(wav)\n\n        with quantity_support():\n            plt.figure()\n            plt.semilogx(wav, flux)\n            plt.axvline(bb.nu_max.to(u.AA, equivalencies=u.spectral()).value, ls='--')\n            plt.show()\n    \"\"\"\n\n    temperature = Parameter(default=5000.0, min=0, unit=u.K, description=\"Blackbody temperature\")\n    scale = Parameter(default=1.0, min=0, description=\"Scale factor\")\n\n    _input_units_allow_dimensionless = True\n\n    input_units_equivalencies = {'x': u.spectral()}\n\n    def evaluate(self, x, temperature, scale):\n        \"\"\"Evaluate the model.\n\n        Parameters\n        ----------\n        x : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['frequency']\n            Frequency at which to compute the blackbody. If no units are given,\n            this defaults to Hz.\n\n        temperature : float, `~numpy.ndarray`, or `~astropy.units.Quantity`\n            Temperature of the blackbody. If no units are given, this defaults\n            to Kelvin.\n\n        scale : float, `~numpy.ndarray`, or `~astropy.units.Quantity` ['dimensionless']\n            Desired scale for the blackbody.\n\n        Returns\n        -------\n        y : number or ndarray\n            Blackbody spectrum. The units are determined from the units of\n            ``scale``.\n\n        .. note::\n\n            Use `numpy.errstate` to suppress Numpy warnings, if desired.\n\n        .. warning::\n\n            Output values might contain ``nan`` and ``inf``.\n\n        Raises\n        ------\n        ValueError\n            Invalid temperature.\n\n        ZeroDivisionError\n            Wavelength is zero (when converting to frequency).\n        \"\"\"\n        if not isinstance(temperature, u.Quantity):\n            in_temp = u.Quantity(temperature, u.K)\n        else:\n            in_temp = temperature\n\n        with u.add_enabled_equivalencies(u.spectral() + u.temperature()):\n            freq = u.Quantity(x, u.Hz, dtype=np.float64)\n            temp = u.Quantity(in_temp, u.K)\n\n        bb_unit = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n        if hasattr(self.scale, \"unit\") and self.scale.unit is not None:\n            if not self.scale.unit.is_equivalent(bb_unit, u.spectral_density(x)):\n                raise ValueError(\n                    f\"scale units not surface brightness: {self.scale.unit}\"\n                )\n            if hasattr(scale, \"unit\"):\n                mult_scale = scale.value\n            else:\n                mult_scale = scale\n            bb_unit = self.scale.unit\n        else:\n            mult_scale = scale\n\n        if np.any(temp < 0):\n            raise ValueError(f\"Temperature should be positive: {temp}\")\n        if not np.all(np.isfinite(freq)) or np.any(freq <= 0):\n            warnings.warn(\n                \"Input contains invalid wavelength/frequency value(s)\",\n                AstropyUserWarning,\n            )\n\n        log_boltz = const.h * freq / (const.k_B * temp)\n        boltzm1 = np.expm1(log_boltz)\n\n        bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr\n\n        y = mult_scale * bb_nu.to(bb_unit, u.spectral_density(freq))\n\n        if hasattr(temperature, \"unit\"):\n            return y\n        return y.value\n\n    @property\n    def input_units(self):\n        return {self.inputs[0]: u.Hz}\n\n    def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n        return {\"temperature\": u.K}\n\n    @property\n    def bolometric_flux(self):\n        \"\"\"Bolometric flux.\"\"\"\n        native_bolflux = (\n            self.scale.value * const.sigma_sb * self.temperature ** 4 / np.pi\n        )\n        return native_bolflux.to(u.erg / (u.cm ** 2 * u.s))\n\n    @property\n    def lambda_max(self):\n        \"\"\"Peak wavelength when the curve is expressed as power density.\"\"\"\n        return const.b_wien / self.temperature\n\n    @property\n    def nu_max(self):\n        \"\"\"Peak frequency when the curve is expressed as power density.\"\"\"\n        return 2.8214391 * const.k_B * self.temperature / const.h",
  "strategy": "llm"
}