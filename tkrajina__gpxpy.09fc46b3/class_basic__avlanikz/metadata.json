{
  "cost": 0.005444910000000001,
  "explanation": "",
  "output": "```python\ndef simplify_polyline(points: List[\"Location\"], max_distance: Optional[float]) -> List[\"Location\"]:\n    \"\"\"Does Ramer-Douglas-Peucker algorithm for simplification of polyline \"\"\"\n\n    _max_distance = max_distance if max_distance is not None else 10\n\n    if len(points) < 3:\n        return points\n\n    begin, end = points[0], points[-1]\n\n    # Use a \"normal\" line just to detect the most distant point (not its real distance)\n    # this is because this is faster to compute than calling distance_from_line() for\n    # every point.\n    #\n    # This is an approximation and may have some errors near the poles and if\n    # the points are too distant, but it should be good enough for most use\n    # cases...\n    a, b, c = get_line_equation_coefficients(begin, end)\n\n    # Initialize to safe values\n    tmp_max_distance: float = 0\n    tmp_max_distance_position = 1\n    \n    # Check distance of all points between begin and end, exclusive\n    for point_no, point in enumerate(points[1:-1], 1):\n        d = abs(a * point.latitude + b * point.longitude + c)\n        if d > tmp_max_distance:\n            tmp_max_distance = d\n            tmp_max_distance_position = point_no\n\n    # Now that we have the most distance point, compute its real distance:\n    real_max_distance = distance_from_line(points[tmp_max_distance_position], begin, end)\n\n    # If furthest point is less than max_distance, remove all points between begin and end\n    if real_max_distance is not None and real_max_distance < _max_distance:\n        return [begin, end]\n    \n    # If furthest point is more than max_distance, use it as anchor and run\n    # function again using (begin to anchor) and (anchor to end), remove extra anchor\n    return (simplify_polyline(points[:tmp_max_distance_position], _max_distance) +\n            simplify_polyline(points[tmp_max_distance_position:], _max_distance))\n```",
  "rewrite": "def simplify_polyline(points: List[\"Location\"], max_distance: Optional[float]) -> List[\"Location\"]:\n    \"\"\"Does Ramer-Douglas-Peucker algorithm for simplification of polyline \"\"\"\n\n    _max_distance = max_distance if max_distance is not None else 10\n\n    if len(points) < 3:\n        return points\n\n    begin, end = points[0], points[-1]\n\n    # Use a \"normal\" line just to detect the most distant point (not its real distance)\n    # this is because this is faster to compute than calling distance_from_line() for\n    # every point.\n    #\n    # This is an approximation and may have some errors near the poles and if\n    # the points are too distant, but it should be good enough for most use\n    # cases...\n    a, b, c = get_line_equation_coefficients(begin, end)\n\n    # Initialize to safe values\n    tmp_max_distance: float = 0\n    tmp_max_distance_position = 1\n    \n    # Check distance of all points between begin and end, exclusive\n    for point_no, point in enumerate(points[1:-1], 1):\n        d = abs(a * point.latitude + b * point.longitude + c)\n        if d > tmp_max_distance:\n            tmp_max_distance = d\n            tmp_max_distance_position = point_no\n\n    # Now that we have the most distance point, compute its real distance:\n    real_max_distance = distance_from_line(points[tmp_max_distance_position], begin, end)\n\n    # If furthest point is less than max_distance, remove all points between begin and end\n    if real_max_distance is not None and real_max_distance < _max_distance:\n        return [begin, end]\n    \n    # If furthest point is more than max_distance, use it as anchor and run\n    # function again using (begin to anchor) and (anchor to end), remove extra anchor\n    return (simplify_polyline(points[:tmp_max_distance_position], _max_distance) +\n            simplify_polyline(points[tmp_max_distance_position:], _max_distance))",
  "strategy": "llm"
}